<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Typescript on It's Go time!</title><link>https://blog.mikesahari.com/tags/typescript/</link><description>Recent content in Typescript on It's Go time!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 14 Mar 2025 21:49:18 -0700</lastBuildDate><atom:link href="https://blog.mikesahari.com/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Go Interfaces</title><link>https://blog.mikesahari.com/posts/interfaces/</link><pubDate>Fri, 14 Mar 2025 21:49:18 -0700</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/interfaces/</guid><description><![CDATA[
        
        <img src="https://blog.mikesahari.com/images/go-learn.svg" width="800" height="150" />
        
        <p>I still remember the moment it clicked. I was knee-deep in refactoring a Go CLI (<em>weekend project</em>) for unit testing with mocks, which had become a tangled mess of dependencies when suddenly â€“ ðŸ¤¯ â€“ the elegance of Go&rsquo;s interface system hit me like a revelation.</p>
<p>It has been many years, but I remember programming in C#; where interfaces were verbose constructs that required explicit declarations and implementation hierarchies. But here was Go, silently composing functionality in a way that felt almost magical.</p>
      ]]></description></item><item><title>Understanding Generic Type Aliases in Go 1.24</title><link>https://blog.mikesahari.com/posts/type-aliases/</link><pubDate>Sat, 15 Feb 2025 09:00:54 -0800</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/type-aliases/</guid><description><![CDATA[
        
        <img src="https://blog.mikesahari.com/images/go-generics.svg" width="800" height="150" />
        
        <p>After spending years writing Go, the introduction of generic type aliases in Go 1.24 is something that I have to say is exciting! Let&rsquo;s break down exactly what this means, how it works, and how it compares to other languages.</p>
<h2 id="understanding-gos-type-system-evolution">Understanding Go&rsquo;s Type System Evolution</h2>
<h3 id="type-aliases-vs-type-definitions">Type Aliases vs Type Definitions</h3>
<p>First, let&rsquo;s clear up a fundamental concept in Go:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Type Definition - Creates a NEW type</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> <span style="color:#66d9ef">int</span>     <span style="color:#75715e">// MyInt is a different type than int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type Alias - Creates a SYNONYM for existing type</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AliasInt</span> = <span style="color:#66d9ef">int</span> <span style="color:#75715e">// AliasInt is exactly the same as int</span>
</span></span></code></pre></div><p>Here&rsquo;s a practical example showing the difference:</p>
      ]]></description></item></channel></rss>