<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on It's Go time!</title><link>https://blog.mikesahari.com/tags/python/</link><description>Recent content in Python on It's Go time!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 14 Mar 2025 21:49:18 -0700</lastBuildDate><atom:link href="https://blog.mikesahari.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Go Interfaces</title><link>https://blog.mikesahari.com/posts/interfaces/</link><pubDate>Fri, 14 Mar 2025 21:49:18 -0700</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/interfaces/</guid><description><![CDATA[
        
        <img src="/images/go-learn.svg" width="300" height="200" alt="Free image by https://github.com/MariaLetta/free-gophers-pack">
<p>I still remember the moment it clicked. I was knee-deep in refactoring a Go CLI (<em>weekend project</em>) for unit testing with mocks, which had become a tangled mess of dependencies when suddenly â€“ ðŸ¤¯ â€“ the elegance of Go&rsquo;s interface system hit me like a revelation.</p>
<p>It has been many years, but I remember programming in C#; where interfaces were verbose constructs that required explicit declarations and implementation hierarchies. But here was Go, silently composing functionality in a way that felt almost magical.</p>
      ]]></description></item><item><title>Understanding Generic Type Aliases in Go 1.24</title><link>https://blog.mikesahari.com/posts/type-aliases/</link><pubDate>Sat, 15 Feb 2025 09:00:54 -0800</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/type-aliases/</guid><description><![CDATA[
        
        <p>After spending years writing Go, the introduction of generic type aliases in Go 1.24 is something that I have to say is exciting! Let&rsquo;s break down exactly what this means, how it works, and how it compares to other languages.</p>
<h2 id="understanding-gos-type-system-evolution">Understanding Go&rsquo;s Type System Evolution</h2>
<h3 id="type-aliases-vs-type-definitions">Type Aliases vs Type Definitions</h3>
<p>First, let&rsquo;s clear up a fundamental concept in Go:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Type Definition - Creates a NEW type</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> <span style="color:#66d9ef">int</span>     <span style="color:#75715e">// MyInt is a different type than int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type Alias - Creates a SYNONYM for existing type</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AliasInt</span> = <span style="color:#66d9ef">int</span> <span style="color:#75715e">// AliasInt is exactly the same as int</span>
</span></span></code></pre></div><p>Here&rsquo;s a practical example showing the difference:</p>
      ]]></description></item><item><title>Go vs Python for Parallel Processing</title><link>https://blog.mikesahari.com/posts/parallel-processing/</link><pubDate>Sat, 01 Feb 2025 10:00:12 -0800</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/parallel-processing/</guid><description><![CDATA[
        
        <p>I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python&rsquo;s strengths - it excels in machine learning and generative AI applications. However, I <strong>prefer</strong> Go for several compelling reasons:</p>
<ul>
<li>Memory management with pointers</li>
<li>Elegant concurrency using channels and goroutines</li>
<li>Straightforward cross-compilation of binaries</li>
<li>Clean implementation of interfaces and structs</li>
</ul>
<p>But preferences often face challenges. Some argue, &ldquo;Python now has concurrency, so you should switch to Python.&rdquo; I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team).</p>
      ]]></description></item></channel></rss>