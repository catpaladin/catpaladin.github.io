<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Python on It's Go time!</title><link>https://blog.mikesahari.com/tags/python/</link><description>Recent content in Python on It's Go time!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><image><url>https://blog.mikesahari.com/images/gopher_favicon.svg</url><title>It's Go time!</title><link>https://blog.mikesahari.com/</link></image><lastBuildDate>Fri, 14 Mar 2025 21:49:18 -0700</lastBuildDate><atom:link href="https://blog.mikesahari.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Go Interfaces</title><link>https://blog.mikesahari.com/posts/interfaces/</link><pubDate>Fri, 14 Mar 2025 21:49:18 -0700</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/interfaces/</guid><media:content url="https://blog.mikesahari.com/images/gophers/go-learn.svg" medium="image" type="image/svg+xml" isDefault="true"/><description><![CDATA[
        <p>I still remember the moment it clicked. I was knee-deep in refactoring a Go CLI (<em>weekend project</em>) for unit testing with mocks, which had become a tangled mess of dependencies when suddenly â€“ ðŸ¤¯ â€“ the elegance of Go&rsquo;s interface system hit me like a revelation.</p>
<p>It has been many years, but I remember programming in C#; where interfaces were verbose constructs that required explicit declarations and implementation hierarchies. But here was Go, silently composing functionality in a way that felt almost magical.</p>
      ]]></description></item><item><title>Understanding Generic Type Aliases in Go 1.24</title><link>https://blog.mikesahari.com/posts/type-aliases/</link><pubDate>Sat, 15 Feb 2025 09:00:54 -0800</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/type-aliases/</guid><media:content url="https://blog.mikesahari.com/images/gophers/go-generics.svg" medium="image" type="image/svg+xml" isDefault="true"/><description><![CDATA[
        <p>After spending years writing Go, the introduction of generic type aliases in Go 1.24 is something that I have to say is exciting! Let&rsquo;s break down exactly what this means, how it works, and how it compares to other languages.</p>
<h2 id="understanding-gos-type-system-evolution">
  <a href="#understanding-gos-type-system-evolution" class="anchor-link group flex items-center no-underline hover:no-underline">
    Understanding Go&rsquo;s Type System Evolution
    <span class="ml-2 opacity-0 group-hover:opacity-100 transition-opacity text-primary">#</span>
  </a>
</h2>
<h3 id="type-aliases-vs-type-definitions">
  <a href="#type-aliases-vs-type-definitions" class="anchor-link group flex items-center no-underline hover:no-underline">
    Type Aliases vs Type Definitions
    <span class="ml-2 opacity-0 group-hover:opacity-100 transition-opacity text-primary">#</span>
  </a>
</h3>
<p>First, let&rsquo;s clear up a fundamental concept in Go:</p>
      ]]></description></item><item><title>Go vs Python for Parallel Processing</title><link>https://blog.mikesahari.com/posts/parallel-processing/</link><pubDate>Sat, 01 Feb 2025 10:00:12 -0800</pubDate><guid isPermaLink="true">https://blog.mikesahari.com/posts/parallel-processing/</guid><media:content url="https://blog.mikesahari.com/images/gophers/go-connect.svg" medium="image" type="image/svg+xml" isDefault="true"/><description><![CDATA[
        <p>I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python&rsquo;s strengths - it excels in machine learning and generative AI applications. However, I <strong>prefer</strong> Go for several compelling reasons:</p>
<ul>
<li>Memory management with pointers</li>
<li>Elegant concurrency using channels and goroutines</li>
<li>Straightforward cross-compilation of binaries</li>
<li>Clean implementation of interfaces and structs</li>
</ul>
<p>But preferences often face challenges. Some argue, &ldquo;Python now has concurrency, so you should switch to Python.&rdquo; I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team).</p>
      ]]></description></item></channel></rss>