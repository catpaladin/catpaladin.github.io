<!doctype html><html lang=en-us><head><title>Mastering DSAs in Go: The Big-O Guide [Part 1] // It's Go time!</title><link rel="shortcut icon" href=images/gopher_favicon.svg><meta charset=utf-8><meta name=generator content="Hugo 0.153.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Mike Sahari"><meta name=description content><meta property="og:site_name" content="It's Go time!"><meta property="og:title" content="Mastering DSAs in Go: The Big-O Guide [Part 1]"><meta property="og:description" content="I&rsquo;ve been really enjoying teaching fundamentals in Go, recently. If you haven&rsquo;t read any
of my other blogs or are new to go, I strongly recommend checking out my
fundamentals posts. I started this
blog as a next step, and before I knew it I was writing something way too long to share.
This will be the first part of a blog series on data structures and algorithms; and of
course, in Go!"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mikesahari.com/posts/dsa-part1-big-o/"><link rel=stylesheet href=/dist/catpaladin-blog.css><script>localStorage.theme==="dark"||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.BLOG_DATA={siteTitle:"It's Go time!",menu:[{Identifier:"blogs",Parent:"",Name:"Blogs",Pre:"",Post:"",URL:"/",PageRef:"",Weight:1,Title:"",Params:null,Menu:"main",ConfiguredURL:"/",Page:null,Children:null},{Identifier:"tags",Parent:"",Name:"Tags",Pre:"",Post:"",URL:"/tags/",PageRef:"",Weight:2,Title:"",Params:null,Menu:"main",ConfiguredURL:"/tags/",Page:null,Children:null},{Identifier:"about",Parent:"",Name:"About",Pre:"",Post:"",URL:"/about/",PageRef:"",Weight:3,Title:"",Params:null,Menu:"main",ConfiguredURL:"/about/",Page:null,Children:null},{Identifier:"rss",Parent:"",Name:"RSS",Pre:"",Post:"",URL:"/index.xml",PageRef:"",Weight:4,Title:"",Params:null,Menu:"main",ConfiguredURL:"/index.xml",Page:null,Children:null}],socials:[{icon:"brand-linkedin",name:"LinkedIn",url:"https://linkedin.com/in/mike-sahari"},{icon:"brand-github",name:"Github",url:"https://github.com/catpaladin"},{icon:"brand-mastodon",name:"Mastodon",url:"https://mastodon.social/@ineedmorecoffee"},{icon:"brand-bluesky",name:"Bluesky",url:"https://bsky.app/profile/msahari.bsky.social"}],description:"A tech blog for Go, Tech, and all the other things I find interesting.",author:"Mike Sahari",isPage:!0,section:"posts"}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Mastering DSAs in Go: The Big-O Guide [Part 1]"><meta name=twitter:description content="I‚Äôve been really enjoying teaching fundamentals in Go, recently. If you haven‚Äôt read any of my other blogs or are new to go, I strongly recommend checking out my fundamentals posts. I started this blog as a next step, and before I knew it I was writing something way too long to share. This will be the first part of a blog series on data structures and algorithms; and of course, in Go!"><meta property="og:url" content="https://blog.mikesahari.com/posts/dsa-part1-big-o/"><meta property="og:site_name" content="It's Go time!"><meta property="og:title" content="Mastering DSAs in Go: The Big-O Guide [Part 1]"><meta property="og:description" content="I‚Äôve been really enjoying teaching fundamentals in Go, recently. If you haven‚Äôt read any of my other blogs or are new to go, I strongly recommend checking out my fundamentals posts. I started this blog as a next step, and before I knew it I was writing something way too long to share. This will be the first part of a blog series on data structures and algorithms; and of course, in Go!"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-05T14:30:41-07:00"><meta property="article:modified_time" content="2025-04-05T14:30:41-07:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Big-O"><meta property="article:tag" content="Computer-Science"></head><body class="transition-colors duration-300"><div id=hugo-content style=display:none aria-hidden=true><div id=hugo-toc><nav id=TableOfContents><ul><li><a href=#what-is-big-o-notation>What is Big-O Notation?</a></li><li><a href=#understanding-complexity-classes-in-practice>Understanding Complexity Classes in Practice</a><ul><li><a href=#o1---constant-time-the-speed-champion>O(1) - Constant Time: The Speed Champion</a></li><li><a href=#olog-n---logarithmic-time-the-efficient-divider>O(log n) - Logarithmic Time: The Efficient Divider</a></li><li><a href=#on---linear-time-the-honest-worker>O(n) - Linear Time: The Honest Worker</a></li><li><a href=#on-log-n---linearithmic-time-the-practical-sorter>O(n log n) - Linearithmic Time: The Practical Sorter</a></li><li><a href=#on---quadratic-time-the-brute-force-approach>O(n¬≤) - Quadratic Time: The Brute-Force Approach</a></li></ul></li><li><a href=#practical-performance-comparison>Practical Performance Comparison</a></li><li><a href=#go-standard-library-performance-tips>Go Standard Library Performance Tips</a></li><li><a href=#beyond-big-o-the-devil-in-the-details>Beyond Big-O: The Devil in the Details</a></li><li><a href=#when-to-optimize>When to Optimize?</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div><main class="max-w-4xl mx-auto px-4 py-12"><article class="max-w-3xl mx-auto"><header class="flex flex-col mb-12"><time datetime=2025-04-05 class="order-first flex items-center text-base text-slate-400 dark:text-slate-500"><span class="h-4 w-0.5 rounded-full bg-slate-200 dark:bg-slate-500 mr-3"></span>
April 5, 2025
<span class=mx-2>¬∑</span>
<span>15 min read</span></time><h1 class="mt-6 text-4xl font-bold tracking-tight text-slate-900 dark:text-white sm:text-5xl">Mastering DSAs in Go: The Big-O Guide [Part 1]</h1><div class="mt-6 flex flex-wrap gap-2"><a href=/tags/go/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Go
</a><a href=/tags/algorithms/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Algorithms
</a><a href=/tags/performance/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Performance
</a><a href=/tags/big-o/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Big-O
</a><a href=/tags/computer-science/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Computer-Science</a></div></header><div class="mb-12 rounded-2xl overflow-hidden shadow-xl"><img src=/images/gophers/go-grow.svg alt="Mastering DSAs in Go: The Big-O Guide [Part 1]" class="w-full h-auto object-cover"></div><div class="prose prose-slate dark:prose-invert max-w-none prose-a:text-primary hover:prose-a:text-primary-dark prose-pre:bg-slate-900 prose-pre:border prose-pre:border-slate-800"><p>I&rsquo;ve been really enjoying teaching fundamentals in Go, recently. If you haven&rsquo;t read any
of my other blogs or are new to go, I strongly recommend checking out my
<a href=https://blog.mikesahari.com/tags/fundamentals/>fundamentals</a> posts. I started this
blog as a next step, and before I knew it I was writing something way too long to share.
This will be the first part of a blog series on data structures and algorithms; and of
course, in Go!</p><p>In my opinion, understanding algorithm complexity is non-negotiable for writing
efficient code. But let&rsquo;s face it, you&rsquo;re not always going to work on a team where
engineers write efficient code (let alone an algorithm!). Even worse, you may work in a
larger team with tech leads that don&rsquo;t understand algorithms; resulting in your newer
engineers missing out on the chance for proper mentorship in coding (or be taught bad
practices!).</p><p><img src=/images/2025/04/20250405-meme1.png alt="think mark think"></p><p>Big-O isn&rsquo;t just academic theory‚Äîit&rsquo;s a practical tool that determines whether your
application will handle 10,000 users or crash when the 101st person logs in. Whether
you&rsquo;re new to Big-O or interested in learning it in Go, this blog will help teach you
about these algorithms.</p><h2 id=what-is-big-o-notation>What is Big-O Notation?</h2><p>Big-O notation is how we describe an algorithm&rsquo;s efficiency as input size grows. It&rsquo;s
like a speed limit sign for your code‚Äîtelling you not how fast your algorithm runs on
your M2 MacBook Pro, but how it will perform when your data grows from kilobytes to
gigabytes.</p><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üìù Note</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert">Big-O notation describes the
worst-case scenario for your algorithm&rsquo;s time or space complexity. It answers: &ldquo;How does
my algorithm&rsquo;s performance scale?&rdquo; rather than &ldquo;How fast is my function right now?&rdquo;</div></div><p>In essence, Big-O focuses on the growth rate of time or space requirements as the input
size increases toward infinity, ignoring constants and lower-order terms that become
insignificant with large inputs.</p><div class=mermaid data-mermaid="Zmxvd2NoYXJ0IExSCiAgICBjbGFzc0RlZiBkZWZhdWx0IGZpbGw6IzJkMzMzYixzdHJva2U6IzNiNDU0ZSxjb2xvcjojYWRiYWM3CiAgICBjbGFzc0RlZiBjb25zdGFudCBmaWxsOiMxYTIzN2Usc3Ryb2tlOiMzOTQ5YWIsY29sb3I6I2U4ZWFmNgogICAgY2xhc3NEZWYgbG9nYXJpdGhtaWMgZmlsbDojMDA0ZDQwLHN0cm9rZTojMDA3OTZiLGNvbG9yOiNlMGYyZjEKICAgIGNsYXNzRGVmIGxpbmVhciBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgY2xhc3NEZWYgbGluZWFyaXRobWljIGZpbGw6IzMxMWI5MixzdHJva2U6IzVlMzViMSxjb2xvcjojZWRlN2Y2CiAgICBjbGFzc0RlZiBxdWFkcmF0aWMgZmlsbDojODgwZTRmLHN0cm9rZTojZDgxYjYwLGNvbG9yOiNmY2U0ZWMKICAgIGNsYXNzRGVmIGV4cG9uZW50aWFsIGZpbGw6IzNlMjcyMyxzdHJva2U6IzZkNGM0MSxjb2xvcjojZWZlYmU5CgogICAgQVsiPGI+Q29tbW9uIEJpZyBPIENvbXBsZXhpdGllczwvYj4iXSAtLT4gQlsiTygxKTogQ29uc3RhbnQiXQogICAgQSAtLT4gQ1siTyhsb2cgbik6IExvZ2FyaXRobWljIl0KICAgIEEgLS0+IERbIk8obik6IExpbmVhciJdCiAgICBBIC0tPiBFWyJPKG4gbG9nIG4pOiBMaW5lYXJpdGhtaWMiXQogICAgQSAtLT4gRlsiTyhuwrIpOiBRdWFkcmF0aWMiXQogICAgQSAtLT4gR1siTygyXm4pOiBFeHBvbmVudGlhbCJdCgogICAgQjo6OmNvbnN0YW50CiAgICBDOjo6bG9nYXJpdGhtaWMKICAgIEQ6OjpsaW5lYXIKICAgIEU6OjpsaW5lYXJpdGhtaWMKICAgIEY6OjpxdWFkcmF0aWMKICAgIEc6OjpleHBvbmVudGlhbA==">flowchart LR
classDef default fill:#2d333b,stroke:#3b454e,color:#adbac7
classDef constant fill:#1a237e,stroke:#3949ab,color:#e8eaf6
classDef logarithmic fill:#004d40,stroke:#00796b,color:#e0f2f1
classDef linear fill:#b71c1c,stroke:#e53935,color:#ffebee
classDef linearithmic fill:#311b92,stroke:#5e35b1,color:#ede7f6
classDef quadratic fill:#880e4f,stroke:#d81b60,color:#fce4ec
classDef exponential fill:#3e2723,stroke:#6d4c41,color:#efebe9
A["&lt;b>Common Big O Complexities&lt;/b>"] --> B["O(1): Constant"]
A --> C["O(log n): Logarithmic"]
A --> D["O(n): Linear"]
A --> E["O(n log n): Linearithmic"]
A --> F["O(n¬≤): Quadratic"]
A --> G["O(2^n): Exponential"]
B:::constant
C:::logarithmic
D:::linear
E:::linearithmic
F:::quadratic
G:::exponential</div><h2 id=understanding-complexity-classes-in-practice>Understanding Complexity Classes in Practice</h2><p>Let&rsquo;s explore these complexity classes with practical Go implementations and see exactly
what happens as our inputs grow.</p><h3 id=o1---constant-time-the-speed-champion>O(1) - Constant Time: The Speed Champion</h3><p><img src=/images/2025/04/20250405-meme2.png alt="speed champion"></p><p>Operations that execute in the same time regardless of input size. This is the gold
standard we strive for.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// GetMapValue is an example of Constant Time</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetMapValue</span>(<span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>exists</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>key</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>exists</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function performs a hash table lookup which takes the same amount of time whether
your map has 10 entries or 10 million. Go&rsquo;s maps are implemented as hash tables, giving
us O(1) average-case access time.</p><p>Here&rsquo;s what happens behind the scenes:</p><div class=mermaid data-mermaid="Zmxvd2NoYXJ0IFRECiAgICBBW1N0YXJ0IEdldE1hcFZhbHVlXSAtLT4gQlsiQ29tcHV0ZSBoYXNoIG9mIGtleSJdCiAgICBCIC0tPiBDWyJMb2NhdGUgYnVja2V0IGJhc2VkIG9uIGhhc2giXQogICAgQyAtLT4gRFsiU2VhcmNoIGJ1Y2tldCBmb3Iga2V5Il0KICAgIEQgLS0+IEV7IktleSBmb3VuZD8ifQogICAgRSAtLT58WWVzfCBGWyJSZXR1cm4gdmFsdWUgYW5kIHRydWUiXQogICAgRSAtLT58Tm98IEdbIlJldHVybiB6ZXJvIHZhbHVlIGFuZCBmYWxzZSJdCgogICAgc3ViZ3JhcGggIlBlcmZvcm1hbmNlIEFuYWx5c2lzIgogICAgSFsiTWFwIHNpemU6IDEwIl0gLS0+IElbIk9wZXJhdGlvbnM6IH4zIl0KICAgIEpbIk1hcCBzaXplOiAxLDAwMCwwMDAiXSAtLT4gS1siT3BlcmF0aW9uczogfjMiXQogICAgZW5kCgogICAgc3R5bGUgQSBmaWxsOiMxYTIzN2Usc3Ryb2tlOiMzOTQ5YWIsY29sb3I6I2U4ZWFmNgogICAgc3R5bGUgQiBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgQyBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgRCBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgc3R5bGUgRSBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgc3R5bGUgRiBmaWxsOiMzMTFiOTIsc3Ryb2tlOiM1ZTM1YjEsY29sb3I6I2VkZTdmNgogICAgc3R5bGUgRyBmaWxsOiM4ODBlNGYsc3Ryb2tlOiNkODFiNjAsY29sb3I6I2ZjZTRlYwogICAgc3R5bGUgSCBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgSSBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgSiBmaWxsOiM0YTE0OGMsc3Ryb2tlOiM3YjFmYTIsY29sb3I6I2YzZTVmNQogICAgc3R5bGUgSyBmaWxsOiM0YTE0OGMsc3Ryb2tlOiM3YjFmYTIsY29sb3I6I2YzZTVmNQ==">flowchart TD
A[Start GetMapValue] --> B["Compute hash of key"]
B --> C["Locate bucket based on hash"]
C --> D["Search bucket for key"]
D --> E{"Key found?"}
E -->|Yes| F["Return value and true"]
E -->|No| G["Return zero value and false"]
subgraph "Performance Analysis"
H["Map size: 10"] --> I["Operations: ~3"]
J["Map size: 1,000,000"] --> K["Operations: ~3"]
end
style A fill:#1a237e,stroke:#3949ab,color:#e8eaf6
style B fill:#004d40,stroke:#00796b,color:#e0f2f1
style C fill:#004d40,stroke:#00796b,color:#e0f2f1
style D fill:#b71c1c,stroke:#e53935,color:#ffebee
style E fill:#b71c1c,stroke:#e53935,color:#ffebee
style F fill:#311b92,stroke:#5e35b1,color:#ede7f6
style G fill:#880e4f,stroke:#d81b60,color:#fce4ec
style H fill:#004d40,stroke:#00796b,color:#e0f2f1
style I fill:#004d40,stroke:#00796b,color:#e0f2f1
style J fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style K fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5</div><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üí° Tip</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert">While Go maps provide O(1) lookups on
average, their worst-case performance can degrade to O(n) under pathological hash
collision cases. In practice, Go&rsquo;s implementation mitigates this by using a good hash
function and automatically growing the hash table when needed.</div></div><p>The beauty of O(1) operations is their predictability‚Äîthey&rsquo;ll perform the same whether
your app has 10 users or 10 million. This is why we love them for hot paths in our code.</p><h3 id=olog-n---logarithmic-time-the-efficient-divider>O(log n) - Logarithmic Time: The Efficient Divider</h3><p><img src=/images/2025/04/20250405-meme3.png alt="binary search"></p><p>Algorithms that reduce the problem size by a fraction (typically half) with each step.
The binary search is the poster child here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BinarySearch is an example of Logarithmic Time</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BinarySearch</span>(<span style=color:#a6e22e>sorted</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>sorted</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>right</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>right</span><span style=color:#f92672>-</span><span style=color:#a6e22e>left</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#75715e>// Avoids integer overflow</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>sorted</span>[<span style=color:#a6e22e>mid</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>target</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mid</span> <span style=color:#75715e>// Found it!</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>sorted</span>[<span style=color:#a6e22e>mid</span>] &lt; <span style=color:#a6e22e>target</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>left</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// Look in the right half</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>sorted</span>[<span style=color:#a6e22e>mid</span>] &gt; <span style=color:#a6e22e>target</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>right</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// Look in the left half</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#75715e>// Target not found</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s trace through this with a concrete example:</p><pre tabindex=0><code>sorted = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
target = 23
</code></pre><ol><li>Initial state: <code>left=0, right=9, mid=4, sorted[mid]=16</code></li><li>16 &lt; 23, so we set <code>left=5</code></li><li>New state: <code>left=5, right=9, mid=7, sorted[mid]=56</code></li><li>56 > 23, so we set <code>right=6</code></li><li>New state: <code>left=5, right=6, mid=5, sorted[mid]=23</code></li><li>23 == 23, return 5</li></ol><p>With just 3 comparisons, we found our target in a list of 10 elements. If we had a
million elements? It would take around 20 comparisons. That&rsquo;s the power of O(log n).</p><div class=mermaid data-mermaid=Zmxvd2NoYXJ0IFRECiAgICBBWyJTdGFydCBCaW5hcnlTZWFyY2giXSAtLT4gQlsibGVmdCA9IDAsIHJpZ2h0ID0gbGVuKHNvcnRlZCktMSJdCiAgICBCIC0tPiBDeyJsZWZ0IDw9IHJpZ2h0PyJ9CiAgICBDIC0tPnxOb3wgRFsiUmV0dXJuIC0xIChOb3QgRm91bmQpIl0KICAgIEMgLS0+fFllc3wgRVsibWlkID0gbGVmdCArIChyaWdodC1sZWZ0KS8yIl0KICAgIEUgLS0+IEZ7InNvcnRlZFttaWRdID09IHRhcmdldD8ifQogICAgRiAtLT58WWVzfCBHWyJSZXR1cm4gbWlkIChGb3VuZCkiXQogICAgRiAtLT58Tm98IEh7InNvcnRlZFttaWRdIDwgdGFyZ2V0PyJ9CiAgICBIIC0tPnxZZXN8IElbImxlZnQgPSBtaWQgKyAxIl0KICAgIEggLS0+fE5vfCBKWyJyaWdodCA9IG1pZCAtIDEiXQogICAgSSAtLT4gQwogICAgSiAtLT4gQwoKICAgIHN1YmdyYXBoICJQZXJmb3JtYW5jZSBHcm93dGgiCiAgICBLWyJFbGVtZW50czogMTAiXSAtLT4gTFsiQ29tcGFyaXNvbnM6IH4zIl0KICAgIE1bIkVsZW1lbnRzOiAxLDAwMCJdIC0tPiBOWyJDb21wYXJpc29uczogfjEwIl0KICAgIE9bIkVsZW1lbnRzOiAxLDAwMCwwMDAiXSAtLT4gUFsiQ29tcGFyaXNvbnM6IH4yMCJdCiAgICBlbmQKCiAgICBzdHlsZSBBIGZpbGw6IzFhMjM3ZSxzdHJva2U6IzM5NDlhYixjb2xvcjojZThlYWY2CiAgICBzdHlsZSBCIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBDIGZpbGw6I2I3MWMxYyxzdHJva2U6I2U1MzkzNSxjb2xvcjojZmZlYmVlCiAgICBzdHlsZSBEIGZpbGw6Izg4MGU0ZixzdHJva2U6I2Q4MWI2MCxjb2xvcjojZmNlNGVjCiAgICBzdHlsZSBFIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBGIGZpbGw6I2I3MWMxYyxzdHJva2U6I2U1MzkzNSxjb2xvcjojZmZlYmVlCiAgICBzdHlsZSBHIGZpbGw6IzMxMWI5MixzdHJva2U6IzVlMzViMSxjb2xvcjojZWRlN2Y2CiAgICBzdHlsZSBIIGZpbGw6I2I3MWMxYyxzdHJva2U6I2U1MzkzNSxjb2xvcjojZmZlYmVlCiAgICBzdHlsZSBJIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBKIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBLIGZpbGw6IzRhMTQ4YyxzdHJva2U6IzdiMWZhMixjb2xvcjojZjNlNWY1CiAgICBzdHlsZSBMIGZpbGw6IzRhMTQ4YyxzdHJva2U6IzdiMWZhMixjb2xvcjojZjNlNWY1CiAgICBzdHlsZSBNIGZpbGw6IzAxNTc5YixzdHJva2U6IzAyODhkMSxjb2xvcjojZTFmNWZlCiAgICBzdHlsZSBOIGZpbGw6IzAxNTc5YixzdHJva2U6IzAyODhkMSxjb2xvcjojZTFmNWZlCiAgICBzdHlsZSBPIGZpbGw6IzNlMjcyMyxzdHJva2U6IzZkNGM0MSxjb2xvcjojZWZlYmU5CiAgICBzdHlsZSBQIGZpbGw6IzNlMjcyMyxzdHJva2U6IzZkNGM0MSxjb2xvcjojZWZlYmU5>flowchart TD
A["Start BinarySearch"] --> B["left = 0, right = len(sorted)-1"]
B --> C{"left &lt;= right?"}
C -->|No| D["Return -1 (Not Found)"]
C -->|Yes| E["mid = left + (right-left)/2"]
E --> F{"sorted[mid] == target?"}
F -->|Yes| G["Return mid (Found)"]
F -->|No| H{"sorted[mid] &lt; target?"}
H -->|Yes| I["left = mid + 1"]
H -->|No| J["right = mid - 1"]
I --> C
J --> C
subgraph "Performance Growth"
K["Elements: 10"] --> L["Comparisons: ~3"]
M["Elements: 1,000"] --> N["Comparisons: ~10"]
O["Elements: 1,000,000"] --> P["Comparisons: ~20"]
end
style A fill:#1a237e,stroke:#3949ab,color:#e8eaf6
style B fill:#004d40,stroke:#00796b,color:#e0f2f1
style C fill:#b71c1c,stroke:#e53935,color:#ffebee
style D fill:#880e4f,stroke:#d81b60,color:#fce4ec
style E fill:#004d40,stroke:#00796b,color:#e0f2f1
style F fill:#b71c1c,stroke:#e53935,color:#ffebee
style G fill:#311b92,stroke:#5e35b1,color:#ede7f6
style H fill:#b71c1c,stroke:#e53935,color:#ffebee
style I fill:#004d40,stroke:#00796b,color:#e0f2f1
style J fill:#004d40,stroke:#00796b,color:#e0f2f1
style K fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style L fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style M fill:#01579b,stroke:#0288d1,color:#e1f5fe
style N fill:#01579b,stroke:#0288d1,color:#e1f5fe
style O fill:#3e2723,stroke:#6d4c41,color:#efebe9
style P fill:#3e2723,stroke:#6d4c41,color:#efebe9</div><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üó®Ô∏è Example</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert"><p>The Go standard library uses
binary search in several places, like the <code>sort.Search</code> function. Here&rsquo;s how you&rsquo;d use
it to find the position to insert a new element while maintaining order:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>FindInsertPosition</span>(<span style=color:#a6e22e>sorted</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Search</span>(len(<span style=color:#a6e22e>sorted</span>), <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sorted</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>Remember that binary search requires sorted data, which is a crucial prerequisite. If
your data isn&rsquo;t sorted, you&rsquo;ll need to sort it first (typically an O(n log n)
operation), which changes the overall performance characteristics.</p><h3 id=on---linear-time-the-honest-worker>O(n) - Linear Time: The Honest Worker</h3><p><img src=/images/2025/04/20250405-meme4.png alt="honest worker"></p><p>Operations where execution time grows in direct proportion to input size. Every element
gets processed exactly once.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ContainsElement is an example of Linear Time</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ContainsElement</span>(<span style=color:#a6e22e>slice</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>slice</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>target</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This might look simple, but don&rsquo;t underestimate it. Linear algorithms are often the best
you can do for unsorted data, and they&rsquo;re predictable and cache-friendly. The time
required scales directly with the input size.</p><div class=mermaid data-mermaid="Zmxvd2NoYXJ0IFRECiAgICBBWyJTdGFydCBDb250YWluc0VsZW1lbnQiXSAtLT4gQlsiaSA9IDAiXQogICAgQiAtLT4gQ3siaSA8IGxlbihzbGljZSk/In0KICAgIEMgLS0+fE5vfCBEWyJSZXR1cm4gZmFsc2UiXQogICAgQyAtLT58WWVzfCBFeyJzbGljZVtpXSA9PSB0YXJnZXQ/In0KICAgIEUgLS0+fFllc3wgRlsiUmV0dXJuIHRydWUiXQogICAgRSAtLT58Tm98IEdbImkrKyJdCiAgICBHIC0tPiBDCgogICAgc3ViZ3JhcGggIlBlcmZvcm1hbmNlIFNjYWxpbmciCiAgICBLWyJFbGVtZW50czogMTAiXSAtLT4gTFsiSXRlcmF0aW9uczogMS0xMCJdCiAgICBNWyJFbGVtZW50czogMSwwMDAiXSAtLT4gTlsiSXRlcmF0aW9uczogMS0xLDAwMCJdCiAgICBPWyJFbGVtZW50czogMSwwMDAsMDAwIl0gLS0+IFBbIkl0ZXJhdGlvbnM6IDEtMSwwMDAsMDAwIl0KICAgIGVuZAoKICAgIHN0eWxlIEEgZmlsbDojMWEyMzdlLHN0cm9rZTojMzk0OWFiLGNvbG9yOiNlOGVhZjYKICAgIHN0eWxlIEIgZmlsbDojMDA0ZDQwLHN0cm9rZTojMDA3OTZiLGNvbG9yOiNlMGYyZjEKICAgIHN0eWxlIEMgZmlsbDojYjcxYzFjLHN0cm9rZTojZTUzOTM1LGNvbG9yOiNmZmViZWUKICAgIHN0eWxlIEQgZmlsbDojODgwZTRmLHN0cm9rZTojZDgxYjYwLGNvbG9yOiNmY2U0ZWMKICAgIHN0eWxlIEUgZmlsbDojYjcxYzFjLHN0cm9rZTojZTUzOTM1LGNvbG9yOiNmZmViZWUKICAgIHN0eWxlIEYgZmlsbDojMzExYjkyLHN0cm9rZTojNWUzNWIxLGNvbG9yOiNlZGU3ZjYKICAgIHN0eWxlIEcgZmlsbDojMDA0ZDQwLHN0cm9rZTojMDA3OTZiLGNvbG9yOiNlMGYyZjEKICAgIHN0eWxlIEsgZmlsbDojNGExNDhjLHN0cm9rZTojN2IxZmEyLGNvbG9yOiNmM2U1ZjUKICAgIHN0eWxlIEwgZmlsbDojNGExNDhjLHN0cm9rZTojN2IxZmEyLGNvbG9yOiNmM2U1ZjUKICAgIHN0eWxlIE0gZmlsbDojMDE1NzliLHN0cm9rZTojMDI4OGQxLGNvbG9yOiNlMWY1ZmUKICAgIHN0eWxlIE4gZmlsbDojMDE1NzliLHN0cm9rZTojMDI4OGQxLGNvbG9yOiNlMWY1ZmUKICAgIHN0eWxlIE8gZmlsbDojM2UyNzIzLHN0cm9rZTojNmQ0YzQxLGNvbG9yOiNlZmViZTkKICAgIHN0eWxlIFAgZmlsbDojM2UyNzIzLHN0cm9rZTojNmQ0YzQxLGNvbG9yOiNlZmViZTk=">flowchart TD
A["Start ContainsElement"] --> B["i = 0"]
B --> C{"i &lt; len(slice)?"}
C -->|No| D["Return false"]
C -->|Yes| E{"slice[i] == target?"}
E -->|Yes| F["Return true"]
E -->|No| G["i++"]
G --> C
subgraph "Performance Scaling"
K["Elements: 10"] --> L["Iterations: 1-10"]
M["Elements: 1,000"] --> N["Iterations: 1-1,000"]
O["Elements: 1,000,000"] --> P["Iterations: 1-1,000,000"]
end
style A fill:#1a237e,stroke:#3949ab,color:#e8eaf6
style B fill:#004d40,stroke:#00796b,color:#e0f2f1
style C fill:#b71c1c,stroke:#e53935,color:#ffebee
style D fill:#880e4f,stroke:#d81b60,color:#fce4ec
style E fill:#b71c1c,stroke:#e53935,color:#ffebee
style F fill:#311b92,stroke:#5e35b1,color:#ede7f6
style G fill:#004d40,stroke:#00796b,color:#e0f2f1
style K fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style L fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style M fill:#01579b,stroke:#0288d1,color:#e1f5fe
style N fill:#01579b,stroke:#0288d1,color:#e1f5fe
style O fill:#3e2723,stroke:#6d4c41,color:#efebe9
style P fill:#3e2723,stroke:#6d4c41,color:#efebe9</div><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üìå Important</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert">Go&rsquo;s slice iteration with
<code>range</code> is highly optimized. The compiler can eliminate bounds checking in many
situations, making linear scans extremely efficient‚Äîsometimes approaching the
theoretical memory bandwidth limit of your hardware.</div></div><p>Linear algorithms are often unavoidable when you need to process all elements at least
once, such as when calculating sums, finding maximum values, or checking if all elements
meet a condition.</p><h3 id=on-log-n---linearithmic-time-the-practical-sorter>O(n log n) - Linearithmic Time: The Practical Sorter</h3><p><img src=/images/2025/04/20250405-meme5.png alt="comparison sorter"></p><p>Found in efficient sorting algorithms and divide-and-conquer approaches, O(n log n)
represents the best possible time complexity for comparison-based sorting.</p><p>Go&rsquo;s standard library sort package implements an optimized version of quicksort (with
insertion sort for small slices) that achieves O(n log n) average-case performance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// QuickSort is an example of Linearithmic Time</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>QuickSort</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Make a copy to avoid modifying input</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>arr</span>))
</span></span><span style=display:flex><span>    copy(<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Call the recursive helper</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quickSortHelper</span>(<span style=color:#a6e22e>result</span>, <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>result</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>quickSortHelper</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>low</span> &lt; <span style=color:#a6e22e>high</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Partition the array and get the pivot index</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pivotIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Recursively sort the sub-arrays</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>quickSortHelper</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>pivotIndex</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>quickSortHelper</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>pivotIndex</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Choose the rightmost element as pivot</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pivot</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>high</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Index of smaller element</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>low</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>low</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>high</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If current element is smaller than the pivot</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>pivot</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Increment index of smaller element</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Swap the pivot element with the element at (i+1)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>high</span>] = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>high</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Return the partition index</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üó®Ô∏è Example</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert"><p>In this example, we used <code>copy</code>.
If you are not familiar with how this works, it accepts a destination slice type and a
source slice type.</p><p>So in our use above, we copied all the values from <code>arr</code> into <code>result</code>. Without this
copy step, you&rsquo;d be modifying the original slice that was passed in, which could lead to
unexpected side effects.</p></div></div><p>Now let&rsquo;s analyze what happens during a quicksort with a small example:</p><pre tabindex=0><code>arr = [38, 27, 43, 3, 9, 82, 10]
</code></pre><p>The recursive partitioning creates a tree-like structure of work:</p><div class=mermaid data-mermaid=Zmxvd2NoYXJ0IFRECiAgICBzdWJncmFwaCAiUXVpY2tTb3J0IFByb2Nlc3MgRXhhbXBsZSIKICAgIEFbIlszOCwgMjcsIDQzLCAzLCA5LCA4MiwgMTBdIl0gLS0+IEJbIlBpdm90ID0gMTAiXQogICAgQiAtLT4gQ1siWzMsIDksIDEwXSArIFszOCwgMjcsIDQzLCA4Ml0iXQogICAgQyAtLT4gRFsiUGl2b3QgPSA5Il0KICAgIEMgLS0+IEVbIlBpdm90ID0gMjciXQogICAgRCAtLT4gRlsiWzNdICsgWzldICsgWzEwXSJdCiAgICBFIC0tPiBHWyJbMjddICsgWzM4LCA0MywgODJdIl0KICAgIEcgLS0+IEhbIlBpdm90ID0gODIiXQogICAgSCAtLT4gSVsiWzM4LCA0M10gKyBbODJdIl0KICAgIEkgLS0+IEpbIlBpdm90ID0gNDMiXQogICAgSiAtLT4gS1siWzM4XSArIFs0M10gKyBbODJdIl0KICAgIGVuZAoKICAgIHN1YmdyYXBoICJQZXJmb3JtYW5jZSBBbmFseXNpcyIKICAgIExbIkVsZW1lbnRzOiAxMCJdIC0tPiBNWyJPcGVyYXRpb25zOiB+MzAiXQogICAgTlsiRWxlbWVudHM6IDEsMDAwIl0gLS0+IE9bIk9wZXJhdGlvbnM6IH4xMCwwMDAiXQogICAgUFsiRWxlbWVudHM6IDEsMDAwLDAwMCJdIC0tPiBRWyJPcGVyYXRpb25zOiB+MjAsMDAwLDAwMCJdCiAgICBlbmQKCiAgICBzdHlsZSBBIGZpbGw6IzFhMjM3ZSxzdHJva2U6IzM5NDlhYixjb2xvcjojZThlYWY2CiAgICBzdHlsZSBCIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBDIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBEIGZpbGw6I2I3MWMxYyxzdHJva2U6I2U1MzkzNSxjb2xvcjojZmZlYmVlCiAgICBzdHlsZSBFIGZpbGw6I2I3MWMxYyxzdHJva2U6I2U1MzkzNSxjb2xvcjojZmZlYmVlCiAgICBzdHlsZSBGIGZpbGw6IzMxMWI5MixzdHJva2U6IzVlMzViMSxjb2xvcjojZWRlN2Y2CiAgICBzdHlsZSBHIGZpbGw6Izg4MGU0ZixzdHJva2U6I2Q4MWI2MCxjb2xvcjojZmNlNGVjCiAgICBzdHlsZSBIIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBJIGZpbGw6IzAwNGQ0MCxzdHJva2U6IzAwNzk2Yixjb2xvcjojZTBmMmYxCiAgICBzdHlsZSBKIGZpbGw6I2I3MWMxYyxzdHJva2U6I2U1MzkzNSxjb2xvcjojZmZlYmVlCiAgICBzdHlsZSBLIGZpbGw6IzMxMWI5MixzdHJva2U6IzVlMzViMSxjb2xvcjojZWRlN2Y2CiAgICBzdHlsZSBMIGZpbGw6IzRhMTQ4YyxzdHJva2U6IzdiMWZhMixjb2xvcjojZjNlNWY1CiAgICBzdHlsZSBNIGZpbGw6IzRhMTQ4YyxzdHJva2U6IzdiMWZhMixjb2xvcjojZjNlNWY1CiAgICBzdHlsZSBOIGZpbGw6IzAxNTc5YixzdHJva2U6IzAyODhkMSxjb2xvcjojZTFmNWZlCiAgICBzdHlsZSBPIGZpbGw6IzAxNTc5YixzdHJva2U6IzAyODhkMSxjb2xvcjojZTFmNWZlCiAgICBzdHlsZSBQIGZpbGw6IzNlMjcyMyxzdHJva2U6IzZkNGM0MSxjb2xvcjojZWZlYmU5CiAgICBzdHlsZSBRIGZpbGw6IzNlMjcyMyxzdHJva2U6IzZkNGM0MSxjb2xvcjojZWZlYmU5>flowchart TD
subgraph "QuickSort Process Example"
A["[38, 27, 43, 3, 9, 82, 10]"] --> B["Pivot = 10"]
B --> C["[3, 9, 10] + [38, 27, 43, 82]"]
C --> D["Pivot = 9"]
C --> E["Pivot = 27"]
D --> F["[3] + [9] + [10]"]
E --> G["[27] + [38, 43, 82]"]
G --> H["Pivot = 82"]
H --> I["[38, 43] + [82]"]
I --> J["Pivot = 43"]
J --> K["[38] + [43] + [82]"]
end
subgraph "Performance Analysis"
L["Elements: 10"] --> M["Operations: ~30"]
N["Elements: 1,000"] --> O["Operations: ~10,000"]
P["Elements: 1,000,000"] --> Q["Operations: ~20,000,000"]
end
style A fill:#1a237e,stroke:#3949ab,color:#e8eaf6
style B fill:#004d40,stroke:#00796b,color:#e0f2f1
style C fill:#004d40,stroke:#00796b,color:#e0f2f1
style D fill:#b71c1c,stroke:#e53935,color:#ffebee
style E fill:#b71c1c,stroke:#e53935,color:#ffebee
style F fill:#311b92,stroke:#5e35b1,color:#ede7f6
style G fill:#880e4f,stroke:#d81b60,color:#fce4ec
style H fill:#004d40,stroke:#00796b,color:#e0f2f1
style I fill:#004d40,stroke:#00796b,color:#e0f2f1
style J fill:#b71c1c,stroke:#e53935,color:#ffebee
style K fill:#311b92,stroke:#5e35b1,color:#ede7f6
style L fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style M fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style N fill:#01579b,stroke:#0288d1,color:#e1f5fe
style O fill:#01579b,stroke:#0288d1,color:#e1f5fe
style P fill:#3e2723,stroke:#6d4c41,color:#efebe9
style Q fill:#3e2723,stroke:#6d4c41,color:#efebe9</div><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üí° Tip</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert"><p>In Go, prefer using the standard
library&rsquo;s <code>sort</code> package for sorting needs rather than implementing your own. It&rsquo;s
well-optimized and handles edge cases properly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For slices of basic types</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For custom sorting</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>people</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Age</span> &lt; <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>Age</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div></div></div><p>The O(n log n) complexity comes from:</p><ul><li>The recursive partitioning creates a tree of height log n (divide)</li><li>At each level, we do about n work comparing elements (conquer)</li></ul><p>This makes it much more efficient than quadratic algorithms for large datasets. When
sorting a million elements, quicksort would perform about 20 million operations compared
to a trillion for bubble sort!</p><h3 id=on---quadratic-time-the-brute-force-approach>O(n¬≤) - Quadratic Time: The Brute-Force Approach</h3><p><img src=/images/2025/04/20250405-meme6.png alt=savages></p><p>Characterized by nested loops, quadratic algorithms quickly become impractical as data
size grows.</p><p>I once had an engineer message me on Slack, asking how I was able to retrieve a ton of
data so fast. He asked if it was because I was using Go and because he was using Python.
When I told him that was part of the reason, he said he was just going to use AI to
rewrite it in Go; but before he went down the vibe coding route with his Cursor setup, I
asked a bunch of leading questions about how he was processing the data. Turns out, he
had vibe coded a very poor implementation of bubble sort (without understanding it)!</p><p>Let&rsquo;s take a look at a cleaner implementation of bubble sort.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Bubble Sort is an example of Quadratic Time</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BubbleSort</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>swapped</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>] &gt; <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>j</span>]
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>swapped</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If no swapping occurred in this pass, the array is sorted</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>swapped</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bubble sort performs comparisons and swaps between adjacent elements, gradually
&ldquo;bubbling&rdquo; the largest elements to their correct positions. Let&rsquo;s walk through it:</p><pre tabindex=0><code>arr = [5, 3, 8, 4, 2]

Pass 1:
Compare 5 &amp; 3 ‚Üí Swap ‚Üí [3, 5, 8, 4, 2]
Compare 5 &amp; 8 ‚Üí No swap ‚Üí [3, 5, 8, 4, 2]
Compare 8 &amp; 4 ‚Üí Swap ‚Üí [3, 5, 4, 8, 2]
Compare 8 &amp; 2 ‚Üí Swap ‚Üí [3, 5, 4, 2, 8]

Pass 2:
Compare 3 &amp; 5 ‚Üí No swap ‚Üí [3, 5, 4, 2, 8]
Compare 5 &amp; 4 ‚Üí Swap ‚Üí [3, 4, 5, 2, 8]
Compare 5 &amp; 2 ‚Üí Swap ‚Üí [3, 4, 2, 5, 8]

Pass 3:
Compare 3 &amp; 4 ‚Üí No swap ‚Üí [3, 4, 2, 5, 8]
Compare 4 &amp; 2 ‚Üí Swap ‚Üí [3, 2, 4, 5, 8]

Pass 4:
Compare 3 &amp; 2 ‚Üí Swap ‚Üí [2, 3, 4, 5, 8]

Final: [2, 3, 4, 5, 8]
</code></pre><div class=mermaid data-mermaid="Zmxvd2NoYXJ0IFRECiAgICBBWyJTdGFydCBCdWJibGVTb3J0Il0gLS0+IEJbIm4gPSBsZW4oYXJyKSJdCiAgICBCIC0tPiBDWyJMb29wIGkgZnJvbSAwIHRvIG4tMSJdCiAgICBDIC0tPiBEWyJzd2FwcGVkID0gZmFsc2UiXQogICAgRCAtLT4gRVsiTG9vcCBqIGZyb20gMCB0byBuLWktMiJdCiAgICBFIC0tPiBGeyJhcnJbal0gPiBhcnJbaisxXT8ifQogICAgRiAtLT58WWVzfCBHWyJTd2FwIGFycltqXSBhbmQgYXJyW2orMV0iXQogICAgRyAtLT4gSFsic3dhcHBlZCA9IHRydWUiXQogICAgRiAtLT58Tm98IElbImorKyJdCiAgICBIIC0tPiBJCiAgICBJIC0tPiBKeyJqIDwgbi1pLTE/In0KICAgIEogLS0+fFllc3wgRQogICAgSiAtLT58Tm98IEt7InN3YXBwZWQ/In0KICAgIEsgLS0+fFllc3wgTFsiaSsrIl0KICAgIEsgLS0+fE5vfCBNWyJCcmVhayBvdXRlciBsb29wIl0KICAgIEwgLS0+IE57ImkgPCBuPyJ9CiAgICBOIC0tPnxZZXN8IEMKICAgIE4gLS0+fE5vfCBPWyJFbmQiXQogICAgTSAtLT4gTwoKICAgIHN1YmdyYXBoICJUaW1lIENvbXBsZXhpdHkgR3Jvd3RoIgogICAgUFsiRWxlbWVudHM6IDEwIl0gLS0+IFFbIkNvbXBhcmlzb25zOiB+NDUiXQogICAgUlsiRWxlbWVudHM6IDEwMCJdIC0tPiBTWyJDb21wYXJpc29uczogfjQsOTUwIl0KICAgIFRbIkVsZW1lbnRzOiAxLDAwMCJdIC0tPiBVWyJDb21wYXJpc29uczogfjQ5OSw1MDAiXQogICAgZW5kCgogICAgc3R5bGUgQSBmaWxsOiMxYTIzN2Usc3Ryb2tlOiMzOTQ5YWIsY29sb3I6I2U4ZWFmNgogICAgc3R5bGUgQiBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgQyBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgRCBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgRSBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgRiBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgc3R5bGUgRyBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgSCBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgSSBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgSiBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgc3R5bGUgSyBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgc3R5bGUgTCBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgTSBmaWxsOiMwMDRkNDAsc3Ryb2tlOiMwMDc5NmIsY29sb3I6I2UwZjJmMQogICAgc3R5bGUgTiBmaWxsOiNiNzFjMWMsc3Ryb2tlOiNlNTM5MzUsY29sb3I6I2ZmZWJlZQogICAgc3R5bGUgTyBmaWxsOiMzMTFiOTIsc3Ryb2tlOiM1ZTM1YjEsY29sb3I6I2VkZTdmNgogICAgc3R5bGUgUCBmaWxsOiM0YTE0OGMsc3Ryb2tlOiM3YjFmYTIsY29sb3I6I2YzZTVmNQogICAgc3R5bGUgUSBmaWxsOiM0YTE0OGMsc3Ryb2tlOiM3YjFmYTIsY29sb3I6I2YzZTVmNQogICAgc3R5bGUgUiBmaWxsOiMwMTU3OWIsc3Ryb2tlOiMwMjg4ZDEsY29sb3I6I2UxZjVmZQogICAgc3R5bGUgUyBmaWxsOiMwMTU3OWIsc3Ryb2tlOiMwMjg4ZDEsY29sb3I6I2UxZjVmZQogICAgc3R5bGUgVCBmaWxsOiMzZTI3MjMsc3Ryb2tlOiM2ZDRjNDEsY29sb3I6I2VmZWJlOQogICAgc3R5bGUgVSBmaWxsOiMzZTI3MjMsc3Ryb2tlOiM2ZDRjNDEsY29sb3I6I2VmZWJlOQ==">flowchart TD
A["Start BubbleSort"] --> B["n = len(arr)"]
B --> C["Loop i from 0 to n-1"]
C --> D["swapped = false"]
D --> E["Loop j from 0 to n-i-2"]
E --> F{"arr[j] > arr[j+1]?"}
F -->|Yes| G["Swap arr[j] and arr[j+1]"]
G --> H["swapped = true"]
F -->|No| I["j++"]
H --> I
I --> J{"j &lt; n-i-1?"}
J -->|Yes| E
J -->|No| K{"swapped?"}
K -->|Yes| L["i++"]
K -->|No| M["Break outer loop"]
L --> N{"i &lt; n?"}
N -->|Yes| C
N -->|No| O["End"]
M --> O
subgraph "Time Complexity Growth"
P["Elements: 10"] --> Q["Comparisons: ~45"]
R["Elements: 100"] --> S["Comparisons: ~4,950"]
T["Elements: 1,000"] --> U["Comparisons: ~499,500"]
end
style A fill:#1a237e,stroke:#3949ab,color:#e8eaf6
style B fill:#004d40,stroke:#00796b,color:#e0f2f1
style C fill:#004d40,stroke:#00796b,color:#e0f2f1
style D fill:#004d40,stroke:#00796b,color:#e0f2f1
style E fill:#004d40,stroke:#00796b,color:#e0f2f1
style F fill:#b71c1c,stroke:#e53935,color:#ffebee
style G fill:#004d40,stroke:#00796b,color:#e0f2f1
style H fill:#004d40,stroke:#00796b,color:#e0f2f1
style I fill:#004d40,stroke:#00796b,color:#e0f2f1
style J fill:#b71c1c,stroke:#e53935,color:#ffebee
style K fill:#b71c1c,stroke:#e53935,color:#ffebee
style L fill:#004d40,stroke:#00796b,color:#e0f2f1
style M fill:#004d40,stroke:#00796b,color:#e0f2f1
style N fill:#b71c1c,stroke:#e53935,color:#ffebee
style O fill:#311b92,stroke:#5e35b1,color:#ede7f6
style P fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style Q fill:#4a148c,stroke:#7b1fa2,color:#f3e5f5
style R fill:#01579b,stroke:#0288d1,color:#e1f5fe
style S fill:#01579b,stroke:#0288d1,color:#e1f5fe
style T fill:#3e2723,stroke:#6d4c41,color:#efebe9
style U fill:#3e2723,stroke:#6d4c41,color:#efebe9</div><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üö® Caution</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert"><p>Quadratic algorithms become
impractical very quickly. For n = 1,000, a bubble sort performs nearly 500,000
comparisons. For n = 1,000,000, it would require about 500 billion comparisons! This is
why we almost never use bubble sort in production code (or do we?).</p><p><img src=/images/2025/04/20250405-meme7.png alt="bubble sort 2 prod"></p></div></div><p>Despite their inefficiency, quadratic algorithms sometimes appear in code bases:</p><ol><li>When processing small datasets where the simplicity of implementation outweighs
performance concerns</li><li>When the nested loops perform constant-time operations, making the code appear
simpler</li><li>In legacy code (languishing) that hasn&rsquo;t been optimized</li></ol><p>Always be suspicious of nested loops in performance-critical code paths, as they often
indicate O(n¬≤) complexity.</p><h2 id=practical-performance-comparison>Practical Performance Comparison</h2><p>To drive home the dramatic differences between these complexity classes, let&rsquo;s look at
how they scale with input size:</p><table><thead><tr><th>Input Size</th><th>O(1)</th><th>O(log n)</th><th>O(n)</th><th>O(n log n)</th><th>O(n¬≤)</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>3</td><td>10</td><td>30</td><td>100</td></tr><tr><td>100</td><td>1</td><td>7</td><td>100</td><td>700</td><td>10,000</td></tr><tr><td>1,000</td><td>1</td><td>10</td><td>1,000</td><td>10,000</td><td>1,000,000</td></tr><tr><td>1,000,000</td><td>1</td><td>20</td><td>1,000,000</td><td>20,000,000</td><td>1,000,000,000,000</td></tr></tbody></table><p>Notice how the O(n¬≤) algorithm becomes completely impractical for large inputs, while
O(log n) barely increases as the input size explodes. This is why binary search on a
sorted array of 1 billion items still completes almost instantly, while a bubble sort
would take years on the same data.</p><h2 id=go-standard-library-performance-tips>Go Standard Library Performance Tips</h2><p>The Go standard library was designed with performance in mind, and its implementations
often use clever optimizations to achieve better-than-expected performance:</p><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üìå Important</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert"><p>Go&rsquo;s slice and map operations
have specific performance characteristics you should know:</p><ul><li><code>append()</code> is amortized O(1) per element, though occasionally it requires O(n) work
for resizing</li><li>Map iterations with <code>range</code> are O(n) but in random order by design</li><li><code>sort.Sort()</code> uses introsort, a hybrid algorithm with O(n log n) complexity</li><li><code>copy()</code> is O(n) where n is the minimum of the destination and source slice lengths</li></ul></div></div><h2 id=beyond-big-o-the-devil-in-the-details>Beyond Big-O: The Devil in the Details</h2><p>While Big-O notation is crucial, it doesn&rsquo;t tell the whole story:</p><ol><li><strong>Constants matter</strong>: An O(n) algorithm with a high constant factor might be slower
than an O(n log n) algorithm for practical input sizes</li><li><strong>Memory access patterns</strong>: Go&rsquo;s slice operations are efficient partly because they
leverage CPU cache locality</li><li><strong>Best/average/worst case</strong>: Some algorithms have different complexity in different
scenarios</li></ol><p>For example, Go&rsquo;s map lookup is O(1) on average but could degrade to O(n) in the worst
case with pathological hash collisions. In practice, this almost never happens due to
Go&rsquo;s implementation details.</p><h2 id=when-to-optimize>When to Optimize?</h2><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üí° Tip</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert">Choosing the right algorithm from the
start isn&rsquo;t premature optimization‚Äîit&rsquo;s good engineering. You can refactor inefficient
code, but you can&rsquo;t refactor a crashed production system while it&rsquo;s broken!</div></div><p>In Go, the general approach should be:</p><ol><li>Choose algorithms with appropriate complexity for your expected data scale</li><li>Write clean, idiomatic Go code</li><li>Profile to identify actual bottlenecks</li><li>Optimize only where needed</li></ol><h2 id=conclusion>Conclusion</h2><p>Understanding Big-O notation is a foundational skill for every Go developer. It helps
you make informed decisions about algorithm selection and predict how your application
will scale as data grows.</p><p>In the next part of this series, we&rsquo;ll dive deeper into data structures and algorithms
in Go!</p><p>Until then, remember: the difference between O(n) and O(n¬≤) might be the difference
between a system that scales smoothly and one that collapses under load.</p><h2 id=references>References</h2><ol><li><a href=https://www.bigocheatsheet.com/>Big O Cheat Sheet</a></li><li><a href=https://blog.golang.org/slices-intro>Go Blog: Slices</a></li><li><a href=https://golang.org/pkg/sort/>Go Standard Library - sort package</a></li><li><a href="https://www.youtube.com/watch?v=HtSuA80QTyo">YouTube: MIT Introduction to Algorithms</a></li><li><a href=https://golang.org/doc/effective_go#maps>Go Documentation - Maps</a></li></ol></div><div class="mt-16 pt-8 border-t border-slate-200 dark:border-slate-800"><h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-6">Recommended Reading</h3><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href=/posts/dsa-part2-data-structures/ class="group flex flex-col p-4 rounded-xl border border-slate-200 dark:border-slate-800 hover:border-primary transition-all hover:shadow-lg dark:hover:bg-slate-800/50"><time class="text-xs text-slate-500 mb-2">May 17, 2025</time><h4 class="text-sm font-bold text-slate-900 dark:text-white group-hover:text-primary transition-colors line-clamp-2">Mastering DSAs in Go - Data Structures [Part 2]</h4><p class="mt-2 text-xs text-slate-600 dark:text-slate-400 line-clamp-3"><p>Hello, Gophers! Welcome to Part 2 of Data Structures and Algorithms. If ‚Ä¶</p></p></a><a href=/posts/go-structs/ class="group flex flex-col p-4 rounded-xl border border-slate-200 dark:border-slate-800 hover:border-primary transition-all hover:shadow-lg dark:hover:bg-slate-800/50"><time class="text-xs text-slate-500 mb-2">Mar 28, 2025</time><h4 class="text-sm font-bold text-slate-900 dark:text-white group-hover:text-primary transition-colors line-clamp-2">Structs Fundamentals: From Basics to Advanced Usage</h4><p class="mt-2 text-xs text-slate-600 dark:text-slate-400 line-clamp-3"><p>If you&rsquo;ve been diving into Go programming (or &ldquo;Golang&rdquo; as the ‚Ä¶</p></p></a><a href=/posts/html-templating/ class="group flex flex-col p-4 rounded-xl border border-slate-200 dark:border-slate-800 hover:border-primary transition-all hover:shadow-lg dark:hover:bg-slate-800/50"><time class="text-xs text-slate-500 mb-2">Mar 21, 2025</time><h4 class="text-sm font-bold text-slate-900 dark:text-white group-hover:text-primary transition-colors line-clamp-2">Modern Templating for Go with Templ</h4><p class="mt-2 text-xs text-slate-600 dark:text-slate-400 line-clamp-3"><p>I&rsquo;ve been working on a handful of personal webdev Go projects, and the one ‚Ä¶</p></p></a></div></div><footer class="mt-16 pt-8 border-t border-slate-200 dark:border-slate-800"></footer></article></main></div><div id=app></div><script src=/dist/app.js defer></script><script data-goatcounter=https://msahari-blog.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>