<!doctype html><html lang=en-us><head><title>Go vs Python for Parallel Processing // It's Go time!</title>
<link rel="shortcut icon" href=images/gopher_favicon.svg><meta charset=utf-8><meta name=generator content="Hugo 0.145.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Mike Sahari"><meta name=description content><link rel=stylesheet href=/css/main.min.b37ba17c9ff2695938f19925e96fb7afaa9d51743ea79f35d668e4e8bacfc19d.css><style>.top-nav{display:flex;align-items:center;justify-content:space-between;padding:12px 24px;background-color:#2c3e50;background-image:linear-gradient(to right,#2c3e50,#4a6785);position:sticky;top:0;z-index:1000;box-shadow:0 2px 8px rgba(0,0,0,.2)}.top-nav-title-link{text-decoration:none;color:inherit;transition:opacity .2s;display:flex;align-items:center;margin-right:auto}.top-nav-title-link:hover{opacity:.85}.top-nav-title{font-weight:700;padding-right:20px;font-size:1.2rem;letter-spacing:.5px;color:#fff;text-shadow:1px 1px 2px rgba(0,0,0,.3)}.top-nav-social{display:flex;align-items:center;margin-right:20px}.top-nav-social a{margin-left:15px;color:#fff;font-size:1.25rem;transition:transform .2s,color .2s}.top-nav-social a:hover{transform:scale(1.15);color:#64b5f6}.menu-container{position:relative;z-index:1000}.menu-button{display:flex;flex-direction:column;justify-content:space-between;width:30px;height:24px;background:0 0;border:none;cursor:pointer;padding:0;transition:transform .2s}.menu-button:hover{transform:scale(1.1)}.menu-button-line{display:block;width:100%;height:3px;background-color:#fff;border-radius:3px;transition:all .3s linear}.menu-button.active .menu-button-line:nth-child(1){transform:translateY(10.5px)rotate(45deg)}.menu-button.active .menu-button-line:nth-child(2){opacity:0}.menu-button.active .menu-button-line:nth-child(3){transform:translateY(-10.5px)rotate(-45deg)}.menu-dropdown{position:absolute;top:35px;right:0;background-color:#2c3e50;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.3);min-width:180px;display:none;padding:10px 0;border-top:3px solid #64b5f6}.menu-dropdown.active{display:block;animation:fadeIn .2s ease-in-out}@keyframes fadeIn{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}.menu-dropdown a{display:block;padding:10px 20px;text-decoration:none;color:#fff;font-size:1rem;transition:background-color .2s}.menu-dropdown a:hover{background-color:rgba(100,181,246,.2);padding-left:24px}@media(max-width:600px){.top-nav{padding:10px 16px}.top-nav-title{font-size:1rem}.top-nav-social a{margin-left:12px}}</style><meta name=twitter:card content="summary"><meta name=twitter:title content="Go vs Python for Parallel Processing"><meta name=twitter:description content="I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python’s strengths - it excels in machine learning and generative AI applications. However, I prefer Go for several compelling reasons:
Memory management with pointers Elegant concurrency using channels and goroutines Straightforward cross-compilation of binaries Clean implementation of interfaces and structs But preferences often face challenges. Some argue, “Python now has concurrency, so you should switch to Python.” I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team)."><meta property="og:url" content="https://blog.mikesahari.com/posts/parallel-processing/"><meta property="og:site_name" content="It's Go time!"><meta property="og:title" content="Go vs Python for Parallel Processing"><meta property="og:description" content="I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python’s strengths - it excels in machine learning and generative AI applications. However, I prefer Go for several compelling reasons:
Memory management with pointers Elegant concurrency using channels and goroutines Straightforward cross-compilation of binaries Clean implementation of interfaces and structs But preferences often face challenges. Some argue, “Python now has concurrency, so you should switch to Python.” I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-01T10:00:12-08:00"><meta property="article:modified_time" content="2025-02-01T10:00:12-08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Python"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Parallelism"></head><body><div id=scroll-indicator-container><div id=scroll-indicator></div></div><div class=top-nav><a href=/ class=top-nav-title-link><span class=top-nav-title>It's Go time!</span></a><div class=top-nav-social><a href=https://linkedin.com/in/mike-sahari target=_blank rel="noreferrer noopener me" aria-label=LinkedIn><svg class="icon icon-brand-linkedin" viewBox="0 0 24 24" fill="currentcolor"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853.0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601.0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144.0-2.063-.926-2.063-2.065.0-1.138.92-2.063 2.063-2.063 1.14.0 2.064.925 2.064 2.063.0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225.0H1.771C.792.0.0.774.0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2.0 22.222.0h.003z"/></svg>
</a><a href=https://github.com/catpaladin target=_blank rel="noreferrer noopener me" aria-label=Github><svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentcolor"><title>GitHub</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
</a><a href=https://mastodon.social/@ineedmorecoffee target=_blank rel="noreferrer noopener me" aria-label=Mastodon><svg class="icon icon-brand-mastodon" viewBox="0 0 24 24" fill="currentcolor"><title>Mastodon</title><path d="M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792.0 11.813.0h-.03c-3.98.0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057.0 00.023-.043v-1.809a.052.052.0 00-.02-.041.053.053.0 00-.046-.01 20.282 20.282.0 01-4.709.545c-2.73.0-3.463-1.284-3.674-1.818a5.593 5.593.0 01-.319-1.433.053.053.0 01.066-.054c1.517.363 3.072.546 4.632.546.376.0.75.0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23.0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112.0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311.0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13.0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"/></svg>
</a><a href=https://bsky.app/profile/msahari.bsky.social target=_blank rel="noreferrer noopener me" aria-label=Bluesky><svg class="icon icon-brand-bluesky" viewBox="0 0 24 24" fill="currentcolor"><title>Bluesky</title><path d="M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565.139 1.908.0 3.08.0 3.768c0 .69.378 5.65.624 6.479.815 2.736 3.713 3.66 6.383 3.364.136-.02.275-.039.415-.056-.138.022-.276.04-.415.056-3.912.58-7.387 2.005-2.83 7.078 5.013 5.19 6.87-1.113 7.823-4.308.953 3.195 2.05 9.271 7.733 4.308 4.267-4.308 1.172-6.498-2.74-7.078a8.741 8.741.0 01-.415-.056c.14.017.279.036.415.056 2.67.297 5.568-.628 6.383-3.364.246-.828.624-5.79.624-6.478.0-.69-.139-1.861-.902-2.206-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8z"/></svg></a></div><div class=menu-container><button class=menu-button aria-label="Toggle menu">
<span class=menu-button-line></span>
<span class=menu-button-line></span>
<span class=menu-button-line></span></button><div class=menu-dropdown><a href=/>Blogs</a>
<a href=/tags/>Tags</a>
<a href=/about/>About</a>
<a href=/index.xml>RSS</a></div></div></div><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Go vs Python for Parallel Processing</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Feb 1, 2025</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
8 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a class=tag href=/tags/go/>Go</a>
<a class=tag href=/tags/python/>Python</a>
<a class=tag href=/tags/concurrency/>Concurrency</a>
<a class=tag href=/tags/parallelism/>Parallelism</a></div></div></header><br><div class=post-featured-image><img src=/images/gophers/go-connect.svg alt="Go vs Python for Parallel Processing"></div><br><div class=post-toc><div class=post-toc-title>Table of Contents</div><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#understanding-the-basics-concurrency-vs-parallelism>Understanding the Basics: Concurrency vs. Parallelism</a><ul><li><a href=#concurrency-example-go><strong>Concurrency Example (Go)</strong></a></li><li><a href=#parallelism-example-python><strong>Parallelism Example (Python)</strong></a></li></ul></li><li><a href=#the-fundamental-difference-gilgill-free-vs-native-concurrency>The Fundamental Difference: GIL/Gill-Free vs Native Concurrency</a><ul><li><a href=#python-evolution-beyond-the-gil><strong>Python: Evolution Beyond the GIL</strong></a></li><li><a href=#cpu_testpy><code>cpu_test.py</code></a></li><li><a href=#go-goroutines-and-channels><strong>Go: Goroutines and Channels</strong></a></li><li><a href=#maingo><code>main.go</code></a></li></ul></li><li><a href=#comparisons>Comparisons</a></li><li><a href=#the-verdict-on-concurrency-go-vs-python->The Verdict on Concurrency: Go vs Python 🎯</a><ul><li><a href=#appropriate-use-cases>Appropriate Use Cases</a></li><li><a href=#misaligned-applications>Misaligned Applications</a></li><li><a href=#future-potential>Future Potential</a></li></ul></li></ul></nav></div></div><style>.post-toc{background-color:#f9f9f9;border:1px solid #ddd;border-radius:8px;padding:15px;margin:20px 0}.post-toc-title{font-weight:700;margin-bottom:10px;color:#00b0ff;font-size:1.2em}.post-toc-content ul{list-style-type:none;padding-left:15px}.post-toc-content ul li{margin-bottom:8px}.post-toc-content ul li a{text-decoration:none;color:#263238;transition:color .2s}.post-toc-content ul li a:hover{color:#00b0ff}@media(prefers-color-scheme:dark){.post-toc{background-color:#263238;border-color:#253031}.post-toc-content ul li a{color:#afbac4}}</style><div class=post-content><p>I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python&rsquo;s strengths - it excels in machine learning and generative AI applications. However, I <strong>prefer</strong> Go for several compelling reasons:</p><ul><li>Memory management with pointers</li><li>Elegant concurrency using channels and goroutines</li><li>Straightforward cross-compilation of binaries</li><li>Clean implementation of interfaces and structs</li></ul><p>But preferences often face challenges. Some argue, &ldquo;Python now has concurrency, so you should switch to Python.&rdquo; I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team).</p><p><img src=/images/2025/02/20250201-meme1.png alt="python simps be like" title="be like that huh"></p><p>This debate sparked my curiosity: how does Python 3.13&rsquo;s new GIL-disabled feature actually perform compared to Go&rsquo;s native concurrency? Let&rsquo;s run through an experiment and find out.</p><h2 id=understanding-the-basics-concurrency-vs-parallelism>Understanding the Basics: Concurrency vs. Parallelism</h2><p>Before we compare Go and Python, let&rsquo;s clarify <strong>two important terms</strong>:</p><ol><li><strong>Concurrency</strong> – The ability to execute multiple tasks at the same time, but not necessarily in parallel. Tasks may start, run, and complete <strong>independently</strong> but share CPU resources.</li><li><strong>Parallelism</strong> – The ability to execute multiple tasks <strong>simultaneously</strong> using multiple CPU cores.</li></ol><p>Think of <strong>concurrency</strong> as multitasking (switching between tasks quickly) and <strong>parallelism</strong> as multiple workers doing different tasks at the same time. I find this important to talk about since I find engineers (or people who like to talk technical) using these interchangeably.</p><h3 id=concurrency-example-go><strong>Concurrency Example (Go)</strong></h3><p>Go allows multiple tasks (goroutines) to be <strong>scheduled efficiently</strong>, even if they&rsquo;re not running in parallel.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doTaskA</span>()  <span style=color:#75715e>// Runs independently</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doTaskB</span>()  <span style=color:#75715e>// Runs independently</span>
</span></span></code></pre></div><h3 id=parallelism-example-python><strong>Parallelism Example (Python)</strong></h3><p>Python uses <strong>multiple processes</strong> to achieve parallelism, where each process runs on a different CPU core.</p><style>.admonition{border-radius:5px;padding:0;border-left:5px solid #00bcf6;box-shadow:0 0 .5rem .2rem #00000025}.admonition-title-container{background-color:#00bcf6;border-top-right-radius:5px}.admonition-title{font-weight:bolder;font-size:large;backdrop-filter:grayscale(50%)brightness(150%);-webkit-backdrop-filter:grayscale(50%)brightness(150%);padding:5px 0 5px 30px;border-top-right-radius:5px}@media(prefers-color-scheme:dark){.admonition-title{backdrop-filter:grayscale(40%)brightness(40%);-webkit-backdrop-filter:grayscale(40%)brightness(40%)}}.admonition-content{padding:10px 0 10px 15px}</style><div class=admonition style="border-left:5px solid #283593"><div class=admonition-title-container style=background-color:#283593><div class=admonition-title>📝 NOTE</div></div><div class=admonition-content>This is true of traditional Python. 3.13 lets you disable the setting that produces this behavior. I will explain that in the next section below.</div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Pool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> Pool(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>as</span> p:  <span style=color:#75715e># 4 parallel workers</span>
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>map(task, range(<span style=color:#ae81ff>10</span>))
</span></span></code></pre></div><h2 id=the-fundamental-difference-gilgill-free-vs-native-concurrency>The Fundamental Difference: GIL/Gill-Free vs Native Concurrency</h2><p>Before I get into the Python analysis, I want to talk about the GIL. For those of you unfamiliar with Python, or those of you that only know enough of it to be dangerous, the GIL is the Global Interpreter Lock. You can read up more on it online, but two key features of it are:</p><ul><li>increased speed of single threaded programs</li><li>easy integration with C libraries</li></ul><h3 id=python-evolution-beyond-the-gil><strong>Python: Evolution Beyond the GIL</strong></h3><p>Starting with Python 3.13, there are two significant approaches to parallel execution:</p><ol><li><p><strong>Traditional GIL-Based Threading</strong>:</p><ul><li>Historical limitation where only one thread can execute Python code at a time</li><li>Still the default behavior for backward compatibility</li><li>Suitable for I/O-bound tasks</li></ul></li><li><p><strong>GIL-Free Execution (Python 3.13+)</strong>:</p><ul><li>Ability to disable GIL for true parallel execution</li><li>Requires explicit opt-in</li><li>Enables CPU-bound tasks to run in parallel</li></ul></li></ol><p>Let&rsquo;s perform a benchmark to show average time with GIL-Based Threading vs GIL-Free Execution. And then after that, I&rsquo;ll show you that Go still beats it.</p><div class=admonition style="border-left:5px solid #283593"><div class=admonition-title-container style=background-color:#283593><div class=admonition-title>📝 NOTE</div></div><div class=admonition-content>Turning off the GIL requires that you either compile it with flags or download it. I just installed it using <a href=https://github.com/pyenv/pyenv>pyenv</a> and appending <code>t</code> to the version.</div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># install 1.13.1 (GIL enabled by default)</span>
</span></span><span style=display:flex><span>pyenv install 1.13.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># install 1.13.1 with GIL disabled</span>
</span></span><span style=display:flex><span>pyenv install 1.13.1t
</span></span></code></pre></div><p>Then you can verify in python with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>print(sys<span style=color:#f92672>.</span>_is_gil_enabled())
</span></span><span style=display:flex><span><span style=color:#75715e># should return False</span>
</span></span></code></pre></div><p>Anyways, here&rsquo;s how to leverage both approaches. First we need a script to test multiprocessing. We&rsquo;ll run it with the GIL enabled first. Then disabled second.</p><h3 id=cpu_testpy><code>cpu_test.py</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> multiprocessing
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> List
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Thread, Event, Lock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CPUBenchmark</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Benchmark class for measuring CPU-bound task performance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, num_threads: int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_threads <span style=color:#f92672>=</span> num_threads
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>completed <span style=color:#f92672>=</span> Event()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cpu_task</span>(self) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;CPU-intensive calculation.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>50_000_000</span>):
</span></span><span style=display:flex><span>            result <span style=color:#f92672>+=</span> (i <span style=color:#f92672>*</span> i) <span style=color:#f92672>/</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>count <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>num_threads:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>completed<span style=color:#f92672>.</span>set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_threads</span>(self) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Execute CPU task across multiple threads.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Returns execution time in seconds.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        start_time <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>perf_counter()
</span></span><span style=display:flex><span>        threads: List[Thread] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Create and start threads</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>num_threads):
</span></span><span style=display:flex><span>            thread <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>cpu_task)
</span></span><span style=display:flex><span>            thread<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>            threads<span style=color:#f92672>.</span>append(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wait for completion</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>            thread<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> time<span style=color:#f92672>.</span>perf_counter() <span style=color:#f92672>-</span> start_time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get system information</span>
</span></span><span style=display:flex><span>    cpu_count <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>cpu_count()
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Python Version: </span><span style=color:#e6db74>{</span>sys<span style=color:#f92672>.</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;CPU Cores: </span><span style=color:#e6db74>{</span>cpu_count<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Run benchmark</span>
</span></span><span style=display:flex><span>    benchmark <span style=color:#f92672>=</span> CPUBenchmark(cpu_count)
</span></span><span style=display:flex><span>    duration <span style=color:#f92672>=</span> benchmark<span style=color:#f92672>.</span>run_threads()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Report results</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Threads: </span><span style=color:#e6db74>{</span>cpu_count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Execution Time: </span><span style=color:#e6db74>{</span>duration<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> seconds&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Average Time per Thread: </span><span style=color:#e6db74>{</span>duration<span style=color:#f92672>/</span>cpu_count<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> seconds&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>Again, I use <code>pyenv</code> to switch between my python versions, but choose whatever method works best.</p><p><code>GIL Enabled Example</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># set my local terminal to use 3.13.1 GIL enabled</span>
</span></span><span style=display:flex><span>pyenv local 3.13.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>python cpu_test.py
</span></span></code></pre></div><p>For me, this had an output of:</p><pre tabindex=0><code>Python Version: 3.13.1
CPU Cores: 16

Threads: 16
Execution Time: 79.27 seconds
Average Time per Thread: 4.95 seconds
</code></pre><p>Next I tested with GIL disabled. This was pretty interesting since I never experimented with it when this first became available.</p><p><code>GIL Disabled Example</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># set my local terminal to use 3.13.1 GIL disabled</span>
</span></span><span style=display:flex><span>pyenv local 3.13.1t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>python cpu_test.py
</span></span></code></pre></div><p>The GIL-free had the output,</p><pre tabindex=0><code>Python Version: 3.13.1 experimental free-threading build
CPU Cores: 16

Threads: 16
Execution Time: 16.19 seconds
Average Time per Thread: 1.01 seconds
</code></pre><p>That was cool and pretty fast. But realistically, when are you going to get a team at work to embrace something experimental because it&rsquo;s faster?</p><p><img src=/images/2025/02/20250201-meme2.png alt=reality title=reality></p><h3 id=go-goroutines-and-channels><strong>Go: Goroutines and Channels</strong></h3><p>Here are some basics on Go&rsquo;s native concurrency:</p><ul><li>Go uses <strong>goroutines</strong>, which are <strong>lightweight</strong> threads managed by the Go runtime.</li><li>Goroutines <strong>do not require OS threads</strong> and have very low memory overhead (~2KB per goroutine).</li><li><strong>Channels</strong> are used to safely share data between goroutines (though I don&rsquo;t think I&rsquo;ll go into them in this blog).</li></ul><p>Let&rsquo;s create a simple Go script. Setup the project and create a Go file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go mod init cputest
</span></span></code></pre></div><h3 id=maingo><code>main.go</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;runtime&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>cpuTask</span>(<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>, <span style=color:#a6e22e>results</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>float64</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// CPU-intensive calculation matching Python example</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>50_000_000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> <span style=color:#f92672>+=</span> float64(<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>i</span>) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>results</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runBenchmark</span>() <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Get number of CPU cores</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>numCPU</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Initialize sync primitives</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>float64</span>, <span style=color:#a6e22e>numCPU</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Record start time</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Launch goroutines</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>numCPU</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>cpuTask</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>, <span style=color:#a6e22e>results</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Wait for completion in separate goroutine</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>		close(<span style=color:#a6e22e>results</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Collect results</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>results</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Process results if needed</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>start</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Configure CPU usage</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>numCPU</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#a6e22e>numCPU</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Print system info</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Go Version: %s\n&#34;</span>, <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Version</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;CPU Cores: %d\n\n&#34;</span>, <span style=color:#a6e22e>numCPU</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Run benchmark</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>duration</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runBenchmark</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Report results</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Execution Time: %.2f seconds\n&#34;</span>, <span style=color:#a6e22e>duration</span>.<span style=color:#a6e22e>Seconds</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Average Time per Goroutine: %.2f seconds\n&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>duration</span>.<span style=color:#a6e22e>Seconds</span>()<span style=color:#f92672>/</span>float64(<span style=color:#a6e22e>numCPU</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next run <code>go run main.go</code> and you should see the output. My example:</p><pre tabindex=0><code>Go Version: go1.23.4
CPU Cores: 16

Execution Time: 0.11 seconds
Average Time per Goroutine: 0.01 seconds
</code></pre><p><img src=/images/2025/02/20250201-meme3.png alt="lets GO" title="lets GO"></p><h2 id=comparisons>Comparisons</h2><p>After diving deep into both Go and Python&rsquo;s parallel processing capabilities, I&rsquo;ve got to say - Go&rsquo;s approach to concurrency is just beautiful in its simplicity. The numbers speak for themselves: 0.11 seconds versus Python&rsquo;s best effort of 16.19 seconds (even with the GIL disabled). That&rsquo;s not just a difference; that&rsquo;s a different league entirely.</p><p>While Python 3.13&rsquo;s GIL-free execution is impressive and shows the language&rsquo;s evolution, it still feels like retrofitting a solution onto an existing problem. Sure, a 5x performance improvement is nothing to sneeze at, but when Go&rsquo;s giving you nearly 150x better performance with a cleaner syntax and simpler mental model? That&rsquo;s hard to ignore.</p><p>Here&rsquo;s the thing - I appreciate what Python&rsquo;s trying to do here. The ability to disable the GIL is a significant step forward, and for existing Python codebases, it&rsquo;s a game-changer. But if I&rsquo;m starting a new project that needs serious concurrent processing? Go&rsquo;s my first choice, no question. The combination of:</p><ul><li>Lightning-fast execution</li><li>Dead-simple goroutine syntax</li><li>Built-in concurrent design patterns</li><li>Production-ready stability</li></ul><p>Just makes it the obvious choice for building modern, concurrent systems. Python might be catching up, but Go was born ready for this stuff.</p><div class=admonition style="border-left:5px solid #283593"><div class=admonition-title-container style=background-color:#283593><div class=admonition-title>📝 NOTE</div></div><div class=admonition-content><p>Go has brought interesting changes to Python before. Python&rsquo;s Protocol system was inspired by Go&rsquo;s interfaces.</p><p>I&rsquo;ve implemented Protocols across several projects. Despite their theoretical benefits, team members often bypass the defined Protocol interfaces, favoring direct code duplication instead.</p></div></div><h2 id=the-verdict-on-concurrency-go-vs-python->The Verdict on Concurrency: Go vs Python 🎯</h2><p>When it comes to concurrent programming, Go isn&rsquo;t just a good choice - it&rsquo;s demonstrably superior. While Python 3.13&rsquo;s GIL-free implementation shows promise, its use cases should be carefully considered.</p><h3 id=appropriate-use-cases>Appropriate Use Cases</h3><p>The GIL-free Python implementation could benefit specific domains:</p><ul><li>Machine Learning workflows requiring parallel processing</li><li>Data science pipelines with CPU-intensive operations</li><li>Scientific computing applications</li><li>A new and simple FastAPI that a Python dev team can maintain</li></ul><h3 id=misaligned-applications>Misaligned Applications</h3><p>However, using GIL-free Python for certain tasks, particularly those already optimized in Go, seems counter-intuitive. For example:</p><ul><li>Writing CLIs that wrap Go-based tools (Terraform, Helm, etc)</li><li>Implementing network services requiring high concurrency</li><li>Building system-level utilities</li></ul><p>Why not just import the packages in Go, and just extend the usage to your use case?</p><h3 id=future-potential>Future Potential</h3><p>The most intriguing potential lies in Python&rsquo;s machine learning ecosystem. Given Python&rsquo;s dominance in ML, the performance improvements from GIL-free execution could significantly impact:</p><ul><li>Training optimization</li><li>Model inference</li><li>Parallel data processing pipelines</li></ul><p>Thanks for diving into this performance comparison with me - now go experiment and build something concurrent, preferably in Go!</p></div><div class=post-footer></div></article></main><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelector(".menu-button"),t=document.querySelector(".menu-dropdown");e&&t&&(e.addEventListener("click",function(){e.classList.toggle("active"),t.classList.toggle("active")}),document.addEventListener("click",function(n){!e.contains(n.target)&&!t.contains(n.target)&&(e.classList.remove("active"),t.classList.remove("active"))}));const s=document.getElementById("scroll-indicator");function n(){const e=document.body.scrollTop||document.documentElement.scrollTop,t=document.documentElement.scrollHeight-document.documentElement.clientHeight,n=e/t*100;s.style.width=n+"%"}window.addEventListener("scroll",n),n()})</script></body></html>