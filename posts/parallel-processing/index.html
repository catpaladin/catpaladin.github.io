<!doctype html><html lang=en-us><head><title>Go vs Python for Parallel Processing // It's Go time!</title><link rel="shortcut icon" href=images/gopher_favicon.svg><meta charset=utf-8><meta name=generator content="Hugo 0.153.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Mike Sahari"><meta name=description content><meta property="og:site_name" content="It's Go time!"><meta property="og:title" content="Go vs Python for Parallel Processing"><meta property="og:description" content="I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python&rsquo;s strengths - it excels in machine learning and generative AI applications. However, I prefer Go for several compelling reasons:

Memory management with pointers
Elegant concurrency using channels and goroutines
Straightforward cross-compilation of binaries
Clean implementation of interfaces and structs

But preferences often face challenges. Some argue, &ldquo;Python now has concurrency, so you should switch to Python.&rdquo; I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team)."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.mikesahari.com/posts/parallel-processing/"><link rel=stylesheet href=/dist/catpaladin-blog.css><script>localStorage.theme==="dark"||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"),window.BLOG_DATA={siteTitle:"It's Go time!",menu:[{Identifier:"blogs",Parent:"",Name:"Blogs",Pre:"",Post:"",URL:"/",PageRef:"",Weight:1,Title:"",Params:null,Menu:"main",ConfiguredURL:"/",Page:null,Children:null},{Identifier:"tags",Parent:"",Name:"Tags",Pre:"",Post:"",URL:"/tags/",PageRef:"",Weight:2,Title:"",Params:null,Menu:"main",ConfiguredURL:"/tags/",Page:null,Children:null},{Identifier:"about",Parent:"",Name:"About",Pre:"",Post:"",URL:"/about/",PageRef:"",Weight:3,Title:"",Params:null,Menu:"main",ConfiguredURL:"/about/",Page:null,Children:null},{Identifier:"rss",Parent:"",Name:"RSS",Pre:"",Post:"",URL:"/index.xml",PageRef:"",Weight:4,Title:"",Params:null,Menu:"main",ConfiguredURL:"/index.xml",Page:null,Children:null}],socials:[{icon:"brand-linkedin",name:"LinkedIn",url:"https://linkedin.com/in/mike-sahari"},{icon:"brand-github",name:"Github",url:"https://github.com/catpaladin"},{icon:"brand-mastodon",name:"Mastodon",url:"https://mastodon.social/@ineedmorecoffee"},{icon:"brand-bluesky",name:"Bluesky",url:"https://bsky.app/profile/msahari.bsky.social"}],description:"A tech blog for Go, Tech, and all the other things I find interesting.",author:"Mike Sahari",isPage:!0,section:"posts"}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Go vs Python for Parallel Processing"><meta name=twitter:description content="I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python‚Äôs strengths - it excels in machine learning and generative AI applications. However, I prefer Go for several compelling reasons:
Memory management with pointers Elegant concurrency using channels and goroutines Straightforward cross-compilation of binaries Clean implementation of interfaces and structs But preferences often face challenges. Some argue, ‚ÄúPython now has concurrency, so you should switch to Python.‚Äù I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team)."><meta property="og:url" content="https://blog.mikesahari.com/posts/parallel-processing/"><meta property="og:site_name" content="It's Go time!"><meta property="og:title" content="Go vs Python for Parallel Processing"><meta property="og:description" content="I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python‚Äôs strengths - it excels in machine learning and generative AI applications. However, I prefer Go for several compelling reasons:
Memory management with pointers Elegant concurrency using channels and goroutines Straightforward cross-compilation of binaries Clean implementation of interfaces and structs But preferences often face challenges. Some argue, ‚ÄúPython now has concurrency, so you should switch to Python.‚Äù I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-01T10:00:12-08:00"><meta property="article:modified_time" content="2025-02-01T10:00:12-08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Python"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Parallelism"></head><body class="transition-colors duration-300"><div id=hugo-content style=display:none aria-hidden=true><div id=hugo-toc><nav id=TableOfContents><ul><li><a href=#understanding-the-basics-concurrency-vs-parallelism>Understanding the Basics: Concurrency vs. Parallelism</a><ul><li><a href=#concurrency-example-go><strong>Concurrency Example (Go)</strong></a></li><li><a href=#parallelism-example-python><strong>Parallelism Example (Python)</strong></a></li></ul></li><li><a href=#the-fundamental-difference-gilgill-free-vs-native-concurrency>The Fundamental Difference: GIL/Gill-Free vs Native Concurrency</a><ul><li><a href=#python-evolution-beyond-the-gil><strong>Python: Evolution Beyond the GIL</strong></a></li><li><a href=#cpu_testpy><code>cpu_test.py</code></a></li><li><a href=#go-goroutines-and-channels><strong>Go: Goroutines and Channels</strong></a></li><li><a href=#maingo><code>main.go</code></a></li></ul></li><li><a href=#comparisons>Comparisons</a></li><li><a href=#the-verdict-on-concurrency-go-vs-python->The Verdict on Concurrency: Go vs Python üéØ</a><ul><li><a href=#appropriate-use-cases>Appropriate Use Cases</a></li><li><a href=#misaligned-applications>Misaligned Applications</a></li><li><a href=#future-potential>Future Potential</a></li></ul></li></ul></nav></div><main class="max-w-4xl mx-auto px-4 py-12"><article class="max-w-3xl mx-auto"><header class="flex flex-col mb-12"><time datetime=2025-02-01 class="order-first flex items-center text-base text-slate-400 dark:text-slate-500"><span class="h-4 w-0.5 rounded-full bg-slate-200 dark:bg-slate-500 mr-3"></span>
February 1, 2025
<span class=mx-2>¬∑</span>
<span>8 min read</span></time><h1 class="mt-6 text-4xl font-bold tracking-tight text-slate-900 dark:text-white sm:text-5xl">Go vs Python for Parallel Processing</h1><div class="mt-6 flex flex-wrap gap-2"><a href=/tags/go/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Go
</a><a href=/tags/python/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Python
</a><a href=/tags/concurrency/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Concurrency
</a><a href=/tags/parallelism/ class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800 dark:bg-slate-800 dark:text-slate-200 hover:bg-primary hover:text-white transition-colors">Parallelism</a></div></header><div class="mb-12 rounded-2xl overflow-hidden shadow-xl"><img src=/images/gophers/go-connect.svg alt="Go vs Python for Parallel Processing" class="w-full h-auto object-cover"></div><div class="prose prose-slate dark:prose-invert max-w-none prose-a:text-primary hover:prose-a:text-primary-dark prose-pre:bg-slate-900 prose-pre:border prose-pre:border-slate-800"><p>I was inspired to write this article after a recent discussion about programming language preferences, specifically questioning my stance on Python. Let me start by acknowledging Python&rsquo;s strengths - it excels in machine learning and generative AI applications. However, I <strong>prefer</strong> Go for several compelling reasons:</p><ul><li>Memory management with pointers</li><li>Elegant concurrency using channels and goroutines</li><li>Straightforward cross-compilation of binaries</li><li>Clean implementation of interfaces and structs</li></ul><p>But preferences often face challenges. Some argue, &ldquo;Python now has concurrency, so you should switch to Python.&rdquo; I fundamentally disagree with this reasoning. Developers should write code in languages they enjoy and find productive. In professional settings, use your preferred language until organizational standards dictate otherwise (i.e. Thou shalt use only thy golden hammer language of the team).</p><p><img src=/images/2025/02/20250201-meme1.png alt="python simps be like" title="be like that huh"></p><p>This debate sparked my curiosity: how does Python 3.13&rsquo;s new GIL-disabled feature actually perform compared to Go&rsquo;s native concurrency? Let&rsquo;s run through an experiment and find out.</p><h2 id=understanding-the-basics-concurrency-vs-parallelism>Understanding the Basics: Concurrency vs. Parallelism</h2><p>Before we compare Go and Python, let&rsquo;s clarify <strong>two important terms</strong>:</p><ol><li><strong>Concurrency</strong> ‚Äì The ability to execute multiple tasks at the same time, but not necessarily in parallel. Tasks may start, run, and complete <strong>independently</strong> but share CPU resources.</li><li><strong>Parallelism</strong> ‚Äì The ability to execute multiple tasks <strong>simultaneously</strong> using multiple CPU cores.</li></ol><p>Think of <strong>concurrency</strong> as multitasking (switching between tasks quickly) and <strong>parallelism</strong> as multiple workers doing different tasks at the same time. I find this important to talk about since I find engineers (or people who like to talk technical) using these interchangeably.</p><h3 id=concurrency-example-go><strong>Concurrency Example (Go)</strong></h3><p>Go allows multiple tasks (goroutines) to be <strong>scheduled efficiently</strong>, even if they&rsquo;re not running in parallel.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doTaskA</span>()  <span style=color:#75715e>// Runs independently</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doTaskB</span>()  <span style=color:#75715e>// Runs independently</span>
</span></span></code></pre></div><h3 id=parallelism-example-python><strong>Parallelism Example (Python)</strong></h3><p>Python uses <strong>multiple processes</strong> to achieve parallelism, where each process runs on a different CPU core.</p><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üìù NOTE</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert">This is true of traditional Python. 3.13 lets you disable the setting that produces this behavior. I will explain that in the next section below.</div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Pool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> Pool(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>as</span> p:  <span style=color:#75715e># 4 parallel workers</span>
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>map(task, range(<span style=color:#ae81ff>10</span>))
</span></span></code></pre></div><h2 id=the-fundamental-difference-gilgill-free-vs-native-concurrency>The Fundamental Difference: GIL/Gill-Free vs Native Concurrency</h2><p>Before I get into the Python analysis, I want to talk about the GIL. For those of you unfamiliar with Python, or those of you that only know enough of it to be dangerous, the GIL is the Global Interpreter Lock. You can read up more on it online, but two key features of it are:</p><ul><li>increased speed of single threaded programs</li><li>easy integration with C libraries</li></ul><h3 id=python-evolution-beyond-the-gil><strong>Python: Evolution Beyond the GIL</strong></h3><p>Starting with Python 3.13, there are two significant approaches to parallel execution:</p><ol><li><p><strong>Traditional GIL-Based Threading</strong>:</p><ul><li>Historical limitation where only one thread can execute Python code at a time</li><li>Still the default behavior for backward compatibility</li><li>Suitable for I/O-bound tasks</li></ul></li><li><p><strong>GIL-Free Execution (Python 3.13+)</strong>:</p><ul><li>Ability to disable GIL for true parallel execution</li><li>Requires explicit opt-in</li><li>Enables CPU-bound tasks to run in parallel</li></ul></li></ol><p>Let&rsquo;s perform a benchmark to show average time with GIL-Based Threading vs GIL-Free Execution. And then after that, I&rsquo;ll show you that Go still beats it.</p><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üìù NOTE</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert">Turning off the GIL requires that you either compile it with flags or download it. I just installed it using <a href=https://github.com/pyenv/pyenv>pyenv</a> and appending <code>t</code> to the version.</div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># install 1.13.1 (GIL enabled by default)</span>
</span></span><span style=display:flex><span>pyenv install 1.13.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># install 1.13.1 with GIL disabled</span>
</span></span><span style=display:flex><span>pyenv install 1.13.1t
</span></span></code></pre></div><p>Then you can verify in python with</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>print(sys<span style=color:#f92672>.</span>_is_gil_enabled())
</span></span><span style=display:flex><span><span style=color:#75715e># should return False</span>
</span></span></code></pre></div><p>Anyways, here&rsquo;s how to leverage both approaches. First we need a script to test multiprocessing. We&rsquo;ll run it with the GIL enabled first. Then disabled second.</p><h3 id=cpu_testpy><code>cpu_test.py</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> multiprocessing
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> List
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Thread, Event, Lock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CPUBenchmark</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Benchmark class for measuring CPU-bound task performance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, num_threads: int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_threads <span style=color:#f92672>=</span> num_threads
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>completed <span style=color:#f92672>=</span> Event()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cpu_task</span>(self) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;CPU-intensive calculation.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>50_000_000</span>):
</span></span><span style=display:flex><span>            result <span style=color:#f92672>+=</span> (i <span style=color:#f92672>*</span> i) <span style=color:#f92672>/</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>count <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>num_threads:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>completed<span style=color:#f92672>.</span>set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_threads</span>(self) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Execute CPU task across multiple threads.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Returns execution time in seconds.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        start_time <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>perf_counter()
</span></span><span style=display:flex><span>        threads: List[Thread] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Create and start threads</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>num_threads):
</span></span><span style=display:flex><span>            thread <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>cpu_task)
</span></span><span style=display:flex><span>            thread<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>            threads<span style=color:#f92672>.</span>append(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wait for completion</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>            thread<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> time<span style=color:#f92672>.</span>perf_counter() <span style=color:#f92672>-</span> start_time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get system information</span>
</span></span><span style=display:flex><span>    cpu_count <span style=color:#f92672>=</span> multiprocessing<span style=color:#f92672>.</span>cpu_count()
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Python Version: </span><span style=color:#e6db74>{</span>sys<span style=color:#f92672>.</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;CPU Cores: </span><span style=color:#e6db74>{</span>cpu_count<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Run benchmark</span>
</span></span><span style=display:flex><span>    benchmark <span style=color:#f92672>=</span> CPUBenchmark(cpu_count)
</span></span><span style=display:flex><span>    duration <span style=color:#f92672>=</span> benchmark<span style=color:#f92672>.</span>run_threads()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Report results</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Threads: </span><span style=color:#e6db74>{</span>cpu_count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Execution Time: </span><span style=color:#e6db74>{</span>duration<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> seconds&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Average Time per Thread: </span><span style=color:#e6db74>{</span>duration<span style=color:#f92672>/</span>cpu_count<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> seconds&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>Again, I use <code>pyenv</code> to switch between my python versions, but choose whatever method works best.</p><p><code>GIL Enabled Example</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># set my local terminal to use 3.13.1 GIL enabled</span>
</span></span><span style=display:flex><span>pyenv local 3.13.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>python cpu_test.py
</span></span></code></pre></div><p>For me, this had an output of:</p><pre tabindex=0><code>Python Version: 3.13.1
CPU Cores: 16

Threads: 16
Execution Time: 79.27 seconds
Average Time per Thread: 4.95 seconds
</code></pre><p>Next I tested with GIL disabled. This was pretty interesting since I never experimented with it when this first became available.</p><p><code>GIL Disabled Example</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># set my local terminal to use 3.13.1 GIL disabled</span>
</span></span><span style=display:flex><span>pyenv local 3.13.1t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>python cpu_test.py
</span></span></code></pre></div><p>The GIL-free had the output,</p><pre tabindex=0><code>Python Version: 3.13.1 experimental free-threading build
CPU Cores: 16

Threads: 16
Execution Time: 16.19 seconds
Average Time per Thread: 1.01 seconds
</code></pre><p>That was cool and pretty fast. But realistically, when are you going to get a team at work to embrace something experimental because it&rsquo;s faster?</p><p><img src=/images/2025/02/20250201-meme2.png alt=reality title=reality></p><h3 id=go-goroutines-and-channels><strong>Go: Goroutines and Channels</strong></h3><p>Here are some basics on Go&rsquo;s native concurrency:</p><ul><li>Go uses <strong>goroutines</strong>, which are <strong>lightweight</strong> threads managed by the Go runtime.</li><li>Goroutines <strong>do not require OS threads</strong> and have very low memory overhead (~2KB per goroutine).</li><li><strong>Channels</strong> are used to safely share data between goroutines (though I don&rsquo;t think I&rsquo;ll go into them in this blog).</li></ul><p>Let&rsquo;s create a simple Go script. Setup the project and create a Go file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go mod init cputest
</span></span></code></pre></div><h3 id=maingo><code>main.go</code></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;runtime&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>cpuTask</span>(<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>, <span style=color:#a6e22e>results</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>float64</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// CPU-intensive calculation matching Python example</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>50_000_000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> <span style=color:#f92672>+=</span> float64(<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>i</span>) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>results</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runBenchmark</span>() <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Get number of CPU cores</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>numCPU</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Initialize sync primitives</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>float64</span>, <span style=color:#a6e22e>numCPU</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Record start time</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Launch goroutines</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>numCPU</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>cpuTask</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>, <span style=color:#a6e22e>results</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Wait for completion in separate goroutine</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>		close(<span style=color:#a6e22e>results</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Collect results</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>results</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Process results if needed</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>start</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Configure CPU usage</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>numCPU</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#a6e22e>numCPU</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Print system info</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Go Version: %s\n&#34;</span>, <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Version</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;CPU Cores: %d\n\n&#34;</span>, <span style=color:#a6e22e>numCPU</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Run benchmark</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>duration</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runBenchmark</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Report results</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Execution Time: %.2f seconds\n&#34;</span>, <span style=color:#a6e22e>duration</span>.<span style=color:#a6e22e>Seconds</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Average Time per Goroutine: %.2f seconds\n&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>duration</span>.<span style=color:#a6e22e>Seconds</span>()<span style=color:#f92672>/</span>float64(<span style=color:#a6e22e>numCPU</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next run <code>go run main.go</code> and you should see the output. My example:</p><pre tabindex=0><code>Go Version: go1.23.4
CPU Cores: 16

Execution Time: 0.11 seconds
Average Time per Goroutine: 0.01 seconds
</code></pre><p><img src=/images/2025/02/20250201-meme3.png alt="lets GO" title="lets GO"></p><h2 id=comparisons>Comparisons</h2><p>After diving deep into both Go and Python&rsquo;s parallel processing capabilities, I&rsquo;ve got to say - Go&rsquo;s approach to concurrency is just beautiful in its simplicity. The numbers speak for themselves: 0.11 seconds versus Python&rsquo;s best effort of 16.19 seconds (even with the GIL disabled). That&rsquo;s not just a difference; that&rsquo;s a different league entirely.</p><p>While Python 3.13&rsquo;s GIL-free execution is impressive and shows the language&rsquo;s evolution, it still feels like retrofitting a solution onto an existing problem. Sure, a 5x performance improvement is nothing to sneeze at, but when Go&rsquo;s giving you nearly 150x better performance with a cleaner syntax and simpler mental model? That&rsquo;s hard to ignore.</p><p>Here&rsquo;s the thing - I appreciate what Python&rsquo;s trying to do here. The ability to disable the GIL is a significant step forward, and for existing Python codebases, it&rsquo;s a game-changer. But if I&rsquo;m starting a new project that needs serious concurrent processing? Go&rsquo;s my first choice, no question. The combination of:</p><ul><li>Lightning-fast execution</li><li>Dead-simple goroutine syntax</li><li>Built-in concurrent design patterns</li><li>Production-ready stability</li></ul><p>Just makes it the obvious choice for building modern, concurrent systems. Python might be catching up, but Go was born ready for this stuff.</p><div class="my-8 rounded-2xl border-l-4 overflow-hidden shadow-lg border-primary bg-white dark:bg-slate-800/50 border-slate-200 dark:border-slate-700 transition-all"><div class="px-6 py-3 font-bold text-white bg-primary">üìù NOTE</div><div class="p-6 text-slate-700 dark:text-slate-200 leading-relaxed prose-sm dark:prose-invert"><p>Go has brought interesting changes to Python before. Python&rsquo;s Protocol system was inspired by Go&rsquo;s interfaces.</p><p>I&rsquo;ve implemented Protocols across several projects. Despite their theoretical benefits, team members often bypass the defined Protocol interfaces, favoring direct code duplication instead.</p></div></div><h2 id=the-verdict-on-concurrency-go-vs-python->The Verdict on Concurrency: Go vs Python üéØ</h2><p>When it comes to concurrent programming, Go isn&rsquo;t just a good choice - it&rsquo;s demonstrably superior. While Python 3.13&rsquo;s GIL-free implementation shows promise, its use cases should be carefully considered.</p><h3 id=appropriate-use-cases>Appropriate Use Cases</h3><p>The GIL-free Python implementation could benefit specific domains:</p><ul><li>Machine Learning workflows requiring parallel processing</li><li>Data science pipelines with CPU-intensive operations</li><li>Scientific computing applications</li><li>A new and simple FastAPI that a Python dev team can maintain</li></ul><h3 id=misaligned-applications>Misaligned Applications</h3><p>However, using GIL-free Python for certain tasks, particularly those already optimized in Go, seems counter-intuitive. For example:</p><ul><li>Writing CLIs that wrap Go-based tools (Terraform, Helm, etc)</li><li>Implementing network services requiring high concurrency</li><li>Building system-level utilities</li></ul><p>Why not just import the packages in Go, and just extend the usage to your use case?</p><h3 id=future-potential>Future Potential</h3><p>The most intriguing potential lies in Python&rsquo;s machine learning ecosystem. Given Python&rsquo;s dominance in ML, the performance improvements from GIL-free execution could significantly impact:</p><ul><li>Training optimization</li><li>Model inference</li><li>Parallel data processing pipelines</li></ul><p>Thanks for diving into this performance comparison with me - now go experiment and build something concurrent, preferably in Go!</p></div><div class="mt-16 pt-8 border-t border-slate-200 dark:border-slate-800"><h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-6">Recommended Reading</h3><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href=/posts/go-channels/ class="group flex flex-col p-4 rounded-xl border border-slate-200 dark:border-slate-800 hover:border-primary transition-all hover:shadow-lg dark:hover:bg-slate-800/50"><time class="text-xs text-slate-500 mb-2">Feb 21, 2025</time><h4 class="text-sm font-bold text-slate-900 dark:text-white group-hover:text-primary transition-colors line-clamp-2">Go Channels: A Concurrency Guide</h4><p class="mt-2 text-xs text-slate-600 dark:text-slate-400 line-clamp-3"><p>Hello fellow Gophers!</p><p>I&rsquo;m absolutely thrilled to dive deep into one of ‚Ä¶</p></p></a><a href=/posts/interfaces/ class="group flex flex-col p-4 rounded-xl border border-slate-200 dark:border-slate-800 hover:border-primary transition-all hover:shadow-lg dark:hover:bg-slate-800/50"><time class="text-xs text-slate-500 mb-2">Mar 14, 2025</time><h4 class="text-sm font-bold text-slate-900 dark:text-white group-hover:text-primary transition-colors line-clamp-2">Understanding Go Interfaces</h4><p class="mt-2 text-xs text-slate-600 dark:text-slate-400 line-clamp-3"><p>I still remember the moment it clicked. I was knee-deep in refactoring a Go CLI ‚Ä¶</p></p></a><a href=/posts/type-aliases/ class="group flex flex-col p-4 rounded-xl border border-slate-200 dark:border-slate-800 hover:border-primary transition-all hover:shadow-lg dark:hover:bg-slate-800/50"><time class="text-xs text-slate-500 mb-2">Feb 15, 2025</time><h4 class="text-sm font-bold text-slate-900 dark:text-white group-hover:text-primary transition-colors line-clamp-2">Understanding Generic Type Aliases in Go 1.24</h4><p class="mt-2 text-xs text-slate-600 dark:text-slate-400 line-clamp-3"><p>After spending years writing Go, the introduction of generic type aliases in Go ‚Ä¶</p></p></a></div></div><footer class="mt-16 pt-8 border-t border-slate-200 dark:border-slate-800"></footer></article></main></div><div id=app></div><script src=/dist/app.js defer></script><script data-goatcounter=https://msahari-blog.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>